---
title: "Quant.creatR"
author: "Charlotte S."
date: "7 février 2018"
output: 
  html_document:
    code_folding: hide
runtime: shiny
---
<br><br>

### **To Read Beforehand**

**Aim of this document:** This sheet has been created to generate automatically the "Quant" file based on the TCD data. Moreover, some data exploration are provided at the end of this document <br>
**WARNING:** Before uploading the file in Quant.CreatR, please check with the TCD_CleanR that the raw TCD file does **NOT** contain any error in required **CONCLUSIONS** (this task may require several run of utilisation of the function TCD_cleanR). If the TCD file is upload without this last verification, Quant.CreatR **CANNOT** garantee the validity of the following data.
<br><br>

### **Information about the session**
```{r echo = FALSE} 
textInput("dateProcessig", label = "", value = "Date of the analysis:")
textInput("Responsible", label = "", value = "Responsible:")
textInput("Temperature", label = "", value = "Lab Temperature:")
textInput("SampleName", label = "", value = "Sample name:")
textInput("system", label = "", value = "System:")
textInput("Column", label = "", value = "Column:")
textInput("temp.Owen", label = "", value = "Temp Owen:")
textInput("carrier.Gas", label = "", value = "Carrier gas:")
textInput("carrier.flow", label = "", value = "Carrier flow:")
textInput("Reference.gas1", label = "", value = "Reference gas 1:")
textInput("Reference.flow1", label = "", value = "Reference flow1:")
textInput("Reference.gas2", label = "", value = "Reference gas 2:")
textInput("Reference.flow2", label = "", value = "Reference flow2:")
textInput("Method", label = "", value = "Method:")
```
<br><br>

### **Preparation of the data**
<br>
```{r include=FALSE, cache=FALSE}
complementVector <- function(VectR, x) {
  
  length.VectR <- length(VectR)
  length.x <- length(x)
  
  y <- vector() #output
  
  for(i in 1:length.VectR) {
    
    if(is.na(match(VectR[i], x))) {
      y <- c(y, i)
    } else {}
    
  }
  
  return(VectR[y])
  
}

# function to ask for the background values
inputs <- function(generalText, TextInput.1, TextInput.2){
  
  xvar <- tclVar("")
  yvar <- tclVar("")
  
  tt <- tktoplevel()
  tkwm.title(tt,paste("Choose", generalText))
  x.entry <- tkentry(tt, textvariable=xvar)
  y.entry <- tkentry(tt, textvariable=yvar)
  
  reset <- function()
  {
    tclvalue(xvar)<-""
    tclvalue(yvar)<-""
  }
  
  reset.but <- tkbutton(tt, text="Reset", command=reset)
  
  submit <- function() {
    x <- as.numeric(tclvalue(xvar))
    y <- as.numeric(tclvalue(yvar))
    e <- parent.env(environment())
    e$x <- x
    e$y <- y
    tkdestroy(tt)
  }
  submit.but <- tkbutton(tt, text="submit", command=submit)
  tkgrid(tklabel(tt,text=TextInput.1), x.entry, pady = 10, padx =10)
  tkgrid(tklabel(tt,text=TextInput.2), y.entry, pady = 10, padx =10)
  tkgrid(submit.but, reset.but)
  
  tkwait.window(tt)
  return(c(x,y))
}

#function for melting two vectors together
PlaceMelting = function(vect, vect2) {
                          
                          vectFinal <- vector()
                          
                          for(i in 1:length(vect)) {
                            for(j in 1: length(vect2)){
                              vectFinal <- c(vectFinal, paste0(vect[i], vect2[j]))
                            }
                          }
                          return(vectFinal)
                        }
```

### 1. Open and set the TCD file

**WARNING:** Before uploading the TCD file, please check with the TCD_cleanR that the TCD.csv does **NOT** contain any error in all the **CONCLUSIONS** (this task may require several run of utilisation of the function TCD_cleanR).

```{r} 
# tkmessageBox(message = "Choose a quant file", type = "ok")
# TCDpath <- tclvalue(tkgetOpenFile())
# if (!nchar(TCDpath)) {
#  tkmessageBox(message = "No file was selected!")
# } else {
#  tkmessageBox(message = paste("The file selected was", TCDpath))
# }
## todo read.xls
TCDpath <- "/home/cha/Dropbox/Post-doc_Danemark/Results/Script/TCD.csv"
TCD <- read.csv(file = TCDpath, h = T, dec = ".", sep = ",")

Rank.Analysis <- 2: (nrow(TCD)+ 1) # +1 to make the excel file correspond to the R file

TCD <- cbind(Rank.Analysis, TCD)

nrow.TCD <- nrow(TCD)
ncol.TCD <- ncol(TCD)

level.identifier.1 <- levels(TCD$Identifier.1)
```
The TCD file chosen is `r TCDpath`
<br><br>

### 2. Open and set the quantitative file
**WARNING:** Before uploading the weight file, please check that the order in TCD file and weight files are the same (checked in the next calculation but the calculations will be stop if this condition is not respected).
```{r} 
# tkmessageBox(message = "Choose the file containing the weight of your sample", type = "ok")
# weightPath <- tclvalue(tkgetOpenFile())
# if (!nchar(weightPath)) {
#  tkmessageBox(message = "No file was selected!")
# } else {
#  tkmessageBox(message = paste("The file selected was", weightPath))
# }
weightPath <- "/home/cha/Dropbox/Post-doc_Danemark/Results/Script/weight.csv"
weightData <- read.csv(weightPath, h = T, dec = ".", sep = ",")
nRow.weightData <- nrow(weightData)
```
The TCD file chosen is `r weightPath`
<br><br>

Select only the name(s) that correspond to samples
```{r}
checkboxGroupInput("sample", label = p(""), 
    choices = level.identifier.1,
    selected = level.identifier.1[3])
```

```{r} 
#### This part aims to split the TCD into two table TCD.standards (containing all the standard and blank values) and TCD.sample (containing only the sample)
dataTables <- reactive({
  sample <- input$sample
  
  place <- NULL
  
  for(x in 1:length(sample)) {
  
  if(x == 1) {
    TCD.sample <- TCD[which(TCD$Identifier.1 == sample[x]), ]
    place <- which(TCD$Identifier.1 == sample[x])
  } else {
    TCD.sample <- rbind(TCD.sample, TCD[which(TCD$Identifier.1 == sample[x]), ])
    place <- c(place, which(TCD$Identifier.1 == sample[x]))
  }
}

place <- sort(place)
PlaceBar <- complementVector(1:nrow.TCD, place)

TCD.sample <- TCD.sample[order(TCD.sample$Rank.Analysis),] # data with only the sample
TCD.standard <- TCD [PlaceBar, ] # data with only the standards

return(list(TCD.sample, TCD.standard))
})


dataStandard <- reactive({
   dataTables()[[2]]
})

dataSample <- reactive({
   dataTables()[[1]]
})

#### Here, the code put the two rArea.Flash.TCD in the line 

quantTable <- reactive({
  
  TCD_dataSample<- dataSample()
  
  nbRow.TCD_dataSample <- nrow(TCD_dataSample)

id.previous.1 <- "NA"
id.previous.2 <- "NA"

temporary.TCDtable <- data.frame(matrix(NA, ncol = 4))

 k <- 1

for(x in 1:nbRow.TCD_dataSample) {
  
  id.1 <- as.character(TCD_dataSample[x,]$Identifier.1)
  id.2 <- as.character(TCD_dataSample[x,]$Identifier.2)
  
  if(!strcmp(id.1,id.previous.1) | !strcmp(id.2, id.previous.2)){
    
    toAdd <- c(id.1, id.2, TCD_dataSample[x,]$rArea.Flash.TCD, TCD_dataSample[x+1,]$rArea.Flash.TCD)
    
    temporary.TCDtable[k,] <- toAdd
    
    k <- k + 1 
  }
  
  id.previous.1 <- id.1
  id.previous.2 <- id.2
  
}
 
 nRow.temporary.TCDtable <- nrow(temporary.TCDtable)
 
 temporary.TCDtable <- cbind(seq(1:nRow.temporary.TCDtable), temporary.TCDtable)
 
 colnames(temporary.TCDtable) <- c("Analysis.Rank", colnames(TCD)[4:5], "Area.Flash.TCD.N", "Area.Flash.TCD.C")
 
 temporary.TCDtable$Area.Flash.TCD.N <- as.numeric(as.character(temporary.TCDtable$Area.Flash.TCD.N))
 temporary.TCDtable$Area.Flash.TCD.C <- as.numeric(as.character(temporary.TCDtable$Area.Flash.TCD.C))
 
 return(temporary.TCDtable)
  
})

output$dataSampleToPrint <- renderDT({
  quantTable()
})

```
<br><br>

### 3. Check graphically the outliers
Please check potential outliers of Area.Flash.TCD.C and Area.Flash.TCD.N
```{r }
output$boxplot <- renderPlot({
  if(length(quantTable()$Area.Flash.TCD.N) != 0 & length(quantTable()$Area.Flash.TCD.C) != 0 & !is.na(quantTable()$Area.Flash.TCD.N) & !is.na(quantTable()$Area.Flash.TCD.C)) {
    par(mfrow = c(1,2), mar = c(2,3,1.2,1.2))
    boxplot(quantTable()$Area.Flash.TCD.N)
    mtext("Area.Flash.TCD.N", side = 1)
    boxplot(quantTable()$Area.Flash.TCD.C, xlab="Area.Flash.TCD.C")
    mtext("Area.Flash.TCD.C", side = 1)
  } else {NULL}
})
```
`r plotOutput('boxplot')`
<br>

### 4. Copy paste weight data
This step requires a table that shows the same order of samples than in the TCD table (after excluding the standards). This condition is verified by quantFile.HelpR (see the conclusions of this paragraph). If these conclusions mention a error in the matching of the sample place, the conclusions of the next paragraphs (see par. 8 and following) should not be considered and the weight file have to be format again before using quantFile.HelpR further. 
```{r}

ToDisplay <- reactive({
  
  errorToCount <- 0 # flag for error
  line.flag <- NA
  
  temporary.TCDtable <- NULL
  
  nRow.temporary.TCDtable <- nrow(quantTable())
  
  if(nRow.temporary.TCDtable != nRow.weightData) {
    errorToCount <- 1
  } else {
      for(i in 1:nRow.temporary.TCDtable){
        if(as.character(quantTable()$Identifier.2[i]) != as.character(weightData$Box.pos[i])){
          errorToCount <- 1
          line.flag <- quantTable()$Identifier.2[i]
          } else {}
      }
      if(errorToCount == 0) {
        temporary.TCDtable <- cbind(quantTable(), weightData$Name, weightData$Measured.Weigth..mg.)
        colnames(temporary.TCDtable)[6:7] <- c("sampleName", "SampleWeight")
      } else {}
  }

  return(list(c(errorToCount, line.flag), temporary.TCDtable))
})

errorToDisplay <- reactive({
  
})

sampleWithWeight <- reactive({
  ToDisplay()[2][[1]]
})

output$errorPrint <- renderText({
  if(ToDisplay()[[1]][1] != 0){
    paste("Be Careful, weight file and TCD do not match on their identifier.2", ToDisplay()[[1]][2])
  } else {}
})
```
`r tableOutput('errorPrint')`
<br>

### 5. Import the background values
Choose the background values (for N and C) for the correction of the Area.Flash.TCD.C and Area.Flash.TCD.N:
```{r}
backgroundValues <- c(0, 1167)

textInput("N.background", label = "N background value", value = backgroundValues[1])
textInput("C.background", label = "C background value", value = backgroundValues[2])

backgroundValues <- reactive({
  return(c(as.numeric(as.character(input$N.background)), as.numeric(as.character(input$C.background))))
})
```
<br>

```{r}

# Here, QuantCreation.helpR corrects of the values Area.Flash.TCD.C & Area.Flash.TCD.N with the background. 
samplewithCorrection <- reactive({
  corrected.N <- sampleWithWeight()$Area.Flash.TCD.N - backgroundValues()[1]
  corrected.C <- sampleWithWeight()$Area.Flash.TCD.C - backgroundValues()[2]
  
  temporary.TCDtable <- cbind(sampleWithWeight(), corrected.N, corrected.C)
  colnames(temporary.TCDtable)[8:9] <- c("Corrected.Area.N", "Corrected.Area.C")
  
  return(temporary.TCDtable)
})
```
<br>

### 6. Creation of the GelA table 
First, choose the content value of the Gel A. The table containing the Gel A will then be edited. 

```{r}
content.GelA <- c(0.16, 0.42)

textInput("N.gelA", label = "GelA N content", value = content.GelA[1])
textInput("C.gelA", label = "GelA C content", value = content.GelA[2])
```

```{r}
checkboxGroupInput("gelA.Name.input", label = p("Then, choose the name that correspond to GelA"), 
    choices = levels(weightData$Name),
    selected = levels(weightData$Name)[1],
    inline =T)
```

```{r}
content.GelA <- reactive({
  return(c(as.numeric(as.character(input$N.gelA)), as.numeric(as.character(input$C.gelA))))
})

gelA.Name <-reactive({
  input$gelA.Name.input
}) 

GelA.table <- reactive({

  tempTable <- samplewithCorrection()[which(samplewithCorrection()$sampleName == gelA.Name()), ]
  
  toPaste <- c(0,0, 0, backgroundValues(), 0, 0, backgroundValues())

  tempTable <- rbind(toPaste, tempTable)
  
  tempTable[1, 2:3] <- c("Blank", "Blank")
  
  mg.N.perCup <- tempTable$SampleWeight * content.GelA()[1] * 1000
  mg.C.perCup <- tempTable$SampleWeight * content.GelA()[2] * 1000
  
  tempTable <- cbind(tempTable, mg.N.perCup, mg.C.perCup)
  # 

  })

output$tableGelA.ToDisplay <- renderDT({
  write.csv(GelA.table(), file = "GelA.table.csv")
  return(GelA.table())
})


```
<br><br>

#### **Final gelA table **
<br><br>
`r DTOutput('tableGelA.ToDisplay')`
<br>
**OBS: **this table has already been saved in an excel sheet called GelA.table.csv
<br><br>

### 7. Linear regressions 
The TCD values will then be corrected based on the linear regression of the gelA value (N and C). To this aim, here are the linear regressions:
<br><br>

#### For **Nitrogen **
```{r}
model.N <- reactive({
  model.N.NR <- lm(GelA.table()$Area.Flash.TCD.N ~ GelA.table()$mg.N.perCup)
  Intercept.N <- summary(model.N.NR)$coefficients[1]
  Slope.N <- summary(model.N.NR)$coefficients[2]
  
  return(c(Intercept.N, Slope.N))
})

output$linearRegression.N <- renderPlot({
  plot(GelA.table()$Area.Flash.TCD.N ~ GelA.table()$mg.N.perCup, ylab = "Area.Flash.TCD.N", xlab = "mg.N.perCup")
  text(GelA.table()$mg.N.perCup, GelA.table()$Area.Flash.TCD.N, labels=GelA.table()$Identifier.2, cex= 0.7, pos=4)
  abline(model.N()[1], model.N()[2], col = 'red')
})

output$modelN <- renderText({
  paste("For N, the parameter of the model: intercept = ", round(model.N()[1],2), " and slope = ", round(model.N()[2], 2))
})
```
`r plotOutput('linearRegression.N')`
`r textOutput('modelN')`
<br><br><br><br>

#### For **Carbon **
```{r}
model.C <- reactive({
  model.C.NR <- lm(GelA.table()$Area.Flash.TCD.C ~ GelA.table()$mg.C.perCup)
  Intercept.C <- summary(model.C.NR)$coefficients[1]
  Slope.C <- summary(model.C.NR)$coefficients[2]
  
  return(c(Intercept.C, Slope.C))
})

output$linearRegression.C <- renderPlot({
  plot(GelA.table()$Area.Flash.TCD.C ~ GelA.table()$mg.C.perCup, ylab = "Area.Flash.TCD.C", xlab = "mg.C.perCup")
  text(GelA.table()$mg.C.perCup, GelA.table()$Area.Flash.TCD.C, labels=GelA.table()$Identifier.2, cex= 0.7, pos=4)
  abline(model.C()[1], model.C()[2], col = 'red')
})

output$modelC <- renderText({
  paste("For C, the parameter of the model: intercept = ", round(model.C()[1],2), " and slope = ", round(model.C()[2], 2))
})
```
`r plotOutput('linearRegression.C')`
`r textOutput('modelC')`
<br>

### 8. Creation of the sample table

```{r}
# Calculation of µg N/Cup, µg C/Cup and C/N
finalTable.Sample <- reactive({
  
  Weight.N.perCup <- samplewithCorrection()$Corrected.Area.N/model.N()[2]
  Weight.C.perCup <- samplewithCorrection()$Corrected.Area.C/model.C()[2]
  
  Weight.N.kg <- Weight.N.perCup/samplewithCorrection()$SampleWeight*1000
  Weight.C.kg <- Weight.C.perCup/samplewithCorrection()$SampleWeight*1000

  C.N.Ratio <- Weight.C.kg/Weight.N.kg

  temporary.TCDtable <- cbind(samplewithCorrection(),Weight.N.perCup, Weight.C.perCup, Weight.N.kg, Weight.C.kg, C.N.Ratio)
  
  return(temporary.TCDtable)
  
})

output$tableSample.ToDisplay <- renderDT({
  write.csv(finalTable.Sample(), file = "finalTable.Sample.csv")
  return(finalTable.Sample())
})
```
<br><br>

#### **Final Sample table**
<br><br>
`r DTOutput('tableSample.ToDisplay')`
<br>
**OBS: **this table has already been saved in an excel sheet called finalTable.Sample.csv
<br><br><br><br>

### **Data exploration**

```{r}
output$pivot <- renderRpivotTable({
  rpivotTable(finalTable.Sample(),width="100%", height="400px")
})
```
`r rpivotTableOutput('pivot')`






