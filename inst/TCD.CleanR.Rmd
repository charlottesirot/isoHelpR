---
title: "TCD.CleanR"
author: "Charlotte S."
date: "8 f√©vrier 2018"
output: 
  html_document:
    code_folding: hide
runtime: shiny
---
<br>

```{r  echo=FALSE, include = FALSE, cache= FALSE}
complementVector <- function(VectR, x) {
  
  length.VectR <- length(VectR)
  length.x <- length(x)
  
  y <- vector() #output
  
  for(i in 1:length.VectR) {
    
    if(is.na(match(VectR[i], x))) {
      y <- c(y, i)
    } else {}
    
  }
  
  return(VectR[y])
  
}
successiveValues <- function(vect) {
  
  length.vect <- length(vect)
  
  i <- 1
  k <- 1
  
  finalList <- list()
  
  while(i < length.vect) {
    
    finalList[k][[1]] <- vect[i]
    
    while(vect[i + 1] == vect[i] +1 & i < length.vect) {
      
      finalList[k][[1]] <- c(finalList[k][[1]], vect[i+1])
      
      i <- i+1
      
    }
    
    i <- i+1
    k <- k+1
    
  }
  
  return(finalList)
  
}
is.null.vector <- function(x) {
  sapply(x, is.null)
}
separateAnalysis_TCD <- function(data, column1) {
  
  vect <- column1
  
  length.vect <- length(vect)
  
  begin <- NULL
  end <- NULL
  
  k <- 1
  
  oneAnalyis <- list()
  
  for (i in 0:(length.vect-1)) {
    
    if(i != 0) {
      if(is.na(vect[i]) & !is.na(vect[i+1])) {
        end <- i
        
        oneAnalyis[[k]] <- begin:end
        
        begin <- i+1
        k <- k+1
        
      } else {}
    } else {
      begin <- 1
    }
    
  }
  
  length.OneAnalysis <- length(oneAnalyis)

  notNA <- which(is.na(vect))

  if(length(unlist(oneAnalyis)) != length.vect) {
    
    toTake <- length.vect - length(unlist(oneAnalyis))
    
    oneAnalyis[[length.OneAnalysis + 1]] <- (length(vect) - toTake +1) : length(vect)
  }
  
  oneAnalyisToReturn <- lapply(1:length(oneAnalyis), function(x) {
    data[oneAnalyis[[x]], ]
  })
  
  return(oneAnalyisToReturn)
  
}
#function for melting two vectors together
PlaceMelting = function(vect, vect2) {
                          
                          vectFinal <- vector()
                          
                          for(i in 1:length(vect)) {
                            for(j in 1: length(vect2)){
                              vectFinal <- c(vectFinal, paste0(vect[i], vect2[j]))
                            }
                          }
                          return(vectFinal)
}
boxplot.with.outlier.label <- function(y, label_name, ..., spread_text = T, data, plot = T, range = 1.5, label.col = "blue", push_text_right = 1.3, # enlarge push_text_right in order to push the text labels further from their point
                                                               segement_width_as_percent_of_label_dist = .45, # Change this if you want to have the line closer to the label (range should be between 0 to 1
                                                               jitter_if_duplicate = T, jitter_only_positive_duplicates = F)
                        {	
                          # notes - this functions doesn't work if there are any missing values in the data.
                          #		You must pre-process the data to make sure it is "complete".
                          
                          
                          # change log:
                          # 19.04.2011 - added support to "names" and "at" parameters.
                          
                          
                          # jitter_if_duplicate - will jitter (Actually just add a bit of numbers) so to be able to decide on which location to plot the label when having identical variables...
                          require(plyr) # for is.formula and ddply
                          
                          # a function to jitter data in case of ties in Y's
                          jitter.duplicate <- function(x, only_positive = F)
                          {
                            if(only_positive) {
                              ss <- x > 0
                            } else {
                              ss <- T
                            }	
                            ss_dup <- duplicated(x[ss])
                            # ss <- ss & ss_dup
                            temp_length <- length(x[ss][ss_dup])	
                            x[ss][ss_dup] <- x[ss][ss_dup] + seq(from = 0.00001, to = 0.00002, length.out = temp_length)
                            x
                          }
                          # jitter.duplicate(c(1:5))
                          # jitter.duplicate(c(1:5,5,2))
                          # duplicated(jitter.duplicate(c(1:5,5,2)))
                          # jitter.duplicate(c(0,0,1:5,5,2))
                          # duplicated(jitter.duplicate(c(0,0,1:5,5,2)))
                          
                          
                          
                          # handle cases where 
                          if(jitter_if_duplicate) {
                            # warning("duplicate jutter of values in y is ON")
                            if(!missing(data)) {	#e.g: we DO have data
                              # if(exists("y") && is.formula(y)) {		# F && NULL # F & NULL
                              y_name <- as.character(substitute(y))	# I could have also used as.list(match.call())
                              # credit to Uwe Ligges and Marc Schwartz for the help
                              # https://mail.google.com/mail/?shva=1#inbox/12dd7ca2f9bfbc39
                              if(length(y_name) > 1) {	# then it is a formula (for example: "~", "y", "x"
                                model_frame_y <- model.frame(y, data = data)
                                temp_y <- model_frame_y[,1]
                                temp_y  <- jitter.duplicate(temp_y, jitter_only_positive_duplicates)	# notice that the default of the function is to work only with positive values...
                                # the_txt <- paste(names(model_frame_y)[1], "temp_y", sep = "<<-") # wrong...
                                the_txt <- paste("data['",names(model_frame_y)[1],"'] <- temp_y", sep = "")				
                                eval(parse(text = the_txt))	# jutter out y var so to be able to handle identical values.
                              } else {	# this isn't a formula
                                data[,y_name] <- jitter.duplicate(data[,y_name], jitter_only_positive_duplicates)
                                y <- data[,y_name]	# this will make it possible for boxplot(y, data) to work later (since it is not supposed to work with data when it's not a formula, but now it does :))
                              }		
                            } else {	# there is no "data"		 
                              if(is.formula(y)) { # if(exists("y") && is.formula(y)) {		# F && NULL # F & NULL
                                temp_y <- model.frame(y)[,1]
                                temp_y  <- jitter.duplicate(temp_y, jitter_only_positive_duplicates)	# notice that the default of the function is to work only with positive values...
                                temp_y_name <- names(model.frame(y))[1]	# we must extract the "names" before introducing a new enbironment (or there will be an error)
                                environment(y) <- new.env()
                                assign(temp_y_name, temp_y, environment(y))
                                # Credit and thanks for doing this goes to Niels Richard Hansen (2 Jan 30, 2011)
                                # http://r.789695.n4.nabble.com/environment-question-changing-variables-from-a-formula-through-model-frame-td3246608.html
                                # warning("Your original variable (in the global environemnt) was just jittered.")	# maybe I should add a user input before doing this....
                                # the_txt <- paste(names(model_frame_y)[1], "temp_y", sep = "<<-")
                                # eval(parse(text = the_txt))	# jutter out y var so to be able to handle identical values.
                              } else {
                                y <- jitter.duplicate(y, jitter_only_positive_duplicates)
                              }		
                            }
                          }
                          # the_txt <- paste("print(",names(model_frame_y)[1], ")")
                          # eval(parse(text = the_txt))	# jutter out y var so to be able to handle identical values.
                          # print(ls())
                          
                          
                          # y should be a formula of the type: y~x, y~a*b
                          # or it could be simply y
                          if(missing(data)) {
                            boxdata <- boxplot(y, plot = plot,range = range ,...)
                          } else {
                            boxdata <- boxplot(y, plot = plot,data = data, range = range ,...)
                          }
                          if(length(boxdata$names) == 1 && boxdata$names =="") boxdata$names <- 1	# this is for cases of type: boxplot(y) (when there is no dependent group)
                          if(length(boxdata$out) == 0 ) {
                            warning("No outliers detected for this boxplot")
                            return(invisible())
                          }
                          
                          if(!missing(data)) attach(data)	# this might lead to problams I should check out for alternatives for using attach here...
                          
                          
                          # creating a data.frame with information from the boxplot output about the outliers (location and group)
                          boxdata_group_name <- factor(boxdata$group)
                          levels(boxdata_group_name) <- boxdata$names[as.numeric(levels(boxdata_group_name))]	# the subseting is for cases where we have some sub groups with no outliers
                          if(!is.null(list(...)$at))	{	# if the user chose to use the "at" parameter, then we would like the function to still function (added on 19.04.2011)
                            boxdata$group <- list(...)$at[boxdata$group]		
                          }
                          boxdata_outlier_df <- data.frame(group = boxdata_group_name, y = boxdata$out, x = boxdata$group)
                          
                          
                          # Let's extract the x,y variables from the formula:
                          if(is.formula(y))
                          {
                            model_frame_y <- model.frame(y)
                            # old solution: (which caused problems if we used the names parameter when using a 2 way formula... (since the order of the names is different then the levels order we get from using factor)
                            # y <- model_frame_y[,1]
                            # x <- model_frame_y[,-1]
                            
                            y <- model_frame_y[,1]
                            x <- model_frame_y[,-1]
                            if(!is.null(dim(x))) {	# then x is a matrix/data.frame of the type x1*x2*..and so on - and we should merge all the variations...
                              x <- apply(x,1, paste, collapse = ".")
                            }
                          } else {
                            # if(missing(x)) x <- rep(1, length(y))
                            x <- rep(1, length(y))	# we do this in case y comes as a vector and without x
                          }	
                          
                          # and put all the variables (x, y, and outlier label name) into one data.frame
                          DATA <- data.frame(label_name, x ,y)
                          
                          if(!is.null(list(...)$names))	{	# if the user chose to use the names parameter, then we would like the function to still function (added on 19.04.2011)
                            DATA$x <- factor(DATA$x, levels = unique(DATA$x))
                            levels(DATA$x) = list(...)$names	# enable us to handle when the user adds the "names" parameter # fixed on 19.04.11	# notice that DATA$x must be of the "correct" order (that's why I used split above
                            # warning("Careful, the use of the 'names' parameter is experimental.  If you notice any errors please e-mail me at: tal.galili@gmail.com")
                          }
                          
                          if(!missing(data)) detach(data)	# we don't need to have "data" attached anymore.
                          
                          # let's only keep the rows with our outliers 
                          boxplot.outlier.data <- function(xx, y_name = "y")
                          {
                            y <- xx[,y_name]
                            boxplot_range <- range(boxplot.stats(y, coef = range )$stats)
                            ss <- (y < boxplot_range[1]) | (y > boxplot_range[2])
                            return(xx[ss,])	
                          }
                          outlier_df <-ddply(DATA, .(x), boxplot.outlier.data)
                          
                          
                          # create propor x/y locations to handle over-laping dots...
                          if(spread_text) {
                            # credit: Greg Snow
                            require(TeachingDemos)		
                            temp_x <- boxdata_outlier_df[,"x"]
                            temp_y1 <- boxdata_outlier_df[,"y"]
                            temp_y2 <- temp_y1
                            for(i in unique(temp_x))
                            {
                              tmp <- temp_x == i
                              temp_y2[ tmp ] <- spread.labs( temp_y2[ tmp ], 1.3*strheight('A'), maxiter=6000, stepsize = 0.05) #, min=0 )
                            }
                            
                          }
                          
                          
                          
                          # max(strwidth(c("asa", "a"))
                          # move_text_right <- max(strwidth(outlier_df[,"label_name"]))	
                          
                          # plotting the outlier labels :)  (I wish there was a non-loop wise way for doing this)
                          for(i in seq_len(dim(boxdata_outlier_df)[1]))
                          {
                            # ss <- (outlier_df[,"x"]  %in% boxdata_outlier_df[i,]$group) & (outlier_df[,"y"] %in% boxdata_outlier_df[i,]$y)
                            
                            # if(jitter_if_duplicate) {
                            # ss <- (outlier_df[,"x"]  %in% boxdata_outlier_df[i,]$group) & closest.number(outlier_df[,"y"]  boxdata_outlier_df[i,]$y)
                            # } else {
                            ss <- (outlier_df[,"x"]  %in% boxdata_outlier_df[i,]$group) & (outlier_df[,"y"] %in% boxdata_outlier_df[i,]$y)
                            # }
                            
                            current_label <- outlier_df[ss,"label_name"]
                            temp_x <- boxdata_outlier_df[i,"x"]
                            temp_y <- boxdata_outlier_df[i,"y"]		
                            # cbind(boxdata_outlier_df,		temp_y2)
                            # outlier_df
                            
                            
                            
                            if(spread_text) {
                              temp_y_new <- temp_y2[i] # not ss			
                              move_text_right <- strwidth(current_label) * push_text_right
                              text( temp_x+move_text_right, temp_y_new, current_label, col = label.col)			
                              # strwidth
                              segments( temp_x+(move_text_right/6), temp_y, temp_x+(move_text_right*segement_width_as_percent_of_label_dist), temp_y_new )
                            } else {
                              text(temp_x, temp_y, current_label, pos = 4, col = label.col)
                            }		
                          }
                          
                          # outputing some of the information we collected
                          invisible(list(boxdata = boxdata, boxdata_outlier_df = boxdata_outlier_df, outlier_df=outlier_df))
                        }
```

### To read beforhand

**Aim of this document:** This sheet has been created to help users to format the TCD file in order to upload it for further calculations. <br>
**WARNING:** This file and its calculations do not correct automatically the TCD file (task dedicated to the user) but rather to point out the error of the raw TCD file. Before uploading the file in the next calculation (put the name of the function), please check with this document that there is **NO** error in all the following **CONCLUSIONS** (this task may require several run of utilisation of the function TCD_cleanR).
**WARNING:** The weight file and the TCD have to list the sample in the same order. 

------------------------------------------------------------------------------------------------------------------------------

### Cleaning and calculation settings 
<br>
```{r echo = F} 

output$info <- renderUI({
  div(column(6,
             fileInput("TCD", label = p("Select the TCD file")),
             textInput("nameSession", label = "", value = "Name of the session"),
             textInput("dateProcessig", label = "", value = "Date of the analysis:"),
             textInput("Responsible", label = "", value = "Responsible:"),
             textInput("Temperature", label = "", value = "Lab Temperature:"),
             textInput("SampleName", label = "", value = "Sample name:"),
             textInput("system", label = "", value = "System:"),
             textInput("Column", label = "", value = "Column:"),
             textInput("temp.Owen", label = "", value = "Temp Owen:")
             ), 
      (column(6,
              fileInput("weightData", label = p("Select the weight file")),
              textInput("carrier.Gas", label = "", value = "Carrier gas:"),
              textInput("carrier.flow", label = "", value = "Carrier flow:"),
              textInput("Reference.gas1", label = "", value = "Reference gas 1:"),
              textInput("Reference.flow1", label = "", value = "Reference flow1:"),
              textInput("Reference.gas2", label = "", value = "Reference gas 2:"),
              textInput("Reference.flow2", label = "", value = "Reference flow2:"),
              textInput("Method", label = "", value = "Method:")
      )
      )
  )
})

output$selectSample <- renderUI({
  
  if(!is.null(input$TCD)) {
  
  level.identifier.1 <- levels(TCD()$Identifier.1)
  
  div(column(12,
             br(),
             checkboxGroupInput("sample", label = p("Select the name(s) that correspond to samples"),
                                choices = level.identifier.1,
                                selected = level.identifier.1[1], 
                                inline = T )
  ))
  
} else {}
  
})
```
`r uiOutput("info")` 
<br><br>
`r uiOutput("selectSample")`
<br><br>

```{r}
TCD <- reactive({
  if(!is.null(input$TCD)) {
    TCD <- read.xls (input$TCD$datapath, sheet = 1, header = TRUE)

    Rank.Analysis <- 2: (nrow(TCD)+ 1) # +1 to make the excel file correspond to the R file

    TCD <- cbind(Rank.Analysis, TCD)

    bad.Id1 <- which(TCD$Identifier.1 == "" | is.na(TCD$Identifier.1) | is.null(TCD$Identifier.1))

    if(length(bad.Id1) != 0) {
      TCD <- TCD[-bad.Id1, ]
    } else {}

    return(TCD)

  }
})

weightData <- reactive({
  if(!is.null(input$weightData)) {
    weightData <- read.xls (input$weightData$datapath, sheet = 1, header = TRUE)

    weightData$Box.pos <- as.character(weightData$Box.pos)

    return(weightData)
  }
})

############################
## Condition 1: identifier.1
############################

bad.Id1 <- reactive({

  if(!is.null(input$TCD)) {

    TCD <- read.xls (input$TCD$datapath, sheet = 1, header = TRUE)

    level.identifier.1 <- levels(TCD$Identifier.1)

    bad.Id1 <- which(TCD$Identifier.1 == "" | is.na(TCD$Identifier.1) | is.null(TCD$Identifier.1))

    return(bad.Id1)

  } else {}
})

output$id1_Error <- renderText({

  if(!is.null(input$TCD)) {

    if(length(bad.Id1()) != 0) {

      toDisplay.1 <- paste("Some identifier.1 are empty. Please remove the line:", paste(bad.Id1(), sep = " ", collapse = ""))

    } else {NULL}

  } else {}

})

output$id1_OK <- renderText({

  if(!is.null(input$TCD)) {

  if(length(bad.Id1()) != 0) {NULL} else {
    toDisplay.1 <- "No problem in the identifier.1"
  }
  } else {}
})

############################
## Condition 2: rArea Flash TCD with exactly three lines
############################

resultMatrix <- reactive({

  if(!is.null(input$TCD)) {

  TCD.liste <- split(TCD(), TCD()$Identifier.1)

  TCD.liste <- TCD.liste[which(names(TCD.liste) != "")]

  sample <- input$sample

  resultMatrix <- matrix(NA,ncol = 9) #the matrix summurizing the number of values in the rArea

  error.id2 <- NULL # test that all the Identifier.2 are identicals
  error.id2.sample <- NULL # test that all the sample have a not empty

  for(i in 1: length(TCD.liste)) {

    dataProv <- TCD.liste[[i]]

    One.Analysis <- separateAnalysis_TCD(dataProv, dataProv$rArea.Flash.TCD)

    number.Analysis <- length(One.Analysis)

    for(j in 1:number.Analysis) {

      if(length(unique(One.Analysis[[j]]$Identifier.2)) == 1) {
        error.id2 <- 0
      } else {
        error.id2 <- 1
      } ### 0 = all the Identifier.2 are identicals, 1 = at least one line has a different Identifier.2
      
      cond <- sapply(1:length(sample), function(x) {length(which(names(TCD.liste)[i] == sample[x]))})

      cond1 <- length(which(cond != 0)) # marker that it's a sample

      cond2 <-   length(which(is.null.vector(One.Analysis[[j]]$Identifier.2) | is.na(One.Analysis[[j]]$Identifier.2) | One.Analysis[[j]]$Identifier.2 == "NA" | One.Analysis[[j]]$Identifier.2 == ""))

      if(cond1 != 0 & cond2 != 0) {
        error.id2.sample <- 1
      } else {
        error.id2.sample <- 0
      } ### 0 = no sample id2 is empty, 1 = at least one line of the sample id2 is empty

      nbValue <- which(!is.na(One.Analysis[[j]]$rArea.Flash.TCD) & !is.null(One.Analysis[[j]]$rArea.Flash.TCD) & One.Analysis[[j]]$rArea.Flash.TCD != "")

      nb.NA <- which(is.na(One.Analysis[[j]]$rArea.Flash.TCD) | is.null(One.Analysis[[j]]$rArea.Flash.TCD) | One.Analysis[[j]]$rArea.Flash.TCD == "")

      toAdd <- c(names(TCD.liste)[i], as.character(One.Analysis[[j]]$Identifier.2)[1], One.Analysis[[j]]$Rank.Analysis[1], length(nbValue), length(nb.NA), error.id2, error.id2.sample, One.Analysis[[j]]$rArea.Flash.TCD[1:2])

      resultMatrix <- rbind(resultMatrix, toAdd)

    }

  }

  resultMatrix <- resultMatrix[-1,]

  colnames(resultMatrix) <- c("Identifier.1", "Identifier.2","FirstLine", "NbValues", "Nb.NA", "error_id.2","error.id2.sample","rArea.Flash.TCD.N", "rArea.Flash.TCD.C")
  rownames(resultMatrix) <- 1:nrow(resultMatrix)
  resultMatrix <- as.data.frame(resultMatrix)
  
  for(i in 3:ncol(resultMatrix)) {
    resultMatrix[,i] <- as.numeric(as.character(resultMatrix[,i]))
  }

  resultMatrix <- resultMatrix[order(resultMatrix[,3]),]

  return(resultMatrix)
  } else {}

})

output$error.nbValue_Error <- renderText({

  if(!is.null(input$TCD)) {

  TCD.liste <- split(TCD(), TCD()$Identifier.1)

  TCD.liste <- TCD.liste[which(names(TCD.liste) != "")]

  sucrose <- names(TCD.liste)[str_detect(names(TCD.liste), "ucrose")]

  error.nbValue <- resultMatrix()$FirstLine[which((resultMatrix()$Identifier.1 ==  sucrose & resultMatrix()$NbValues != 1) | (resultMatrix()$Identifier.1 !=  sucrose & resultMatrix()$NbValues != 2))]

  if(length(error.nbValue) > 0) {

    paste("There is a mistake in the number of values. Check the line(s):", paste(error.nbValue, sep = " ", collapse = " "))

  } else {}

  } else {}

})

output$error.nbValue_OK <- renderText({

    if(!is.null(input$TCD)) {

      TCD.liste <- split(TCD(), TCD()$Identifier.1)

      TCD.liste <- TCD.liste[which(names(TCD.liste) != "")]

      sucrose <- names(TCD.liste)[str_detect(names(TCD.liste), "ucrose")]

      error.nbValue <- resultMatrix()$FirstLine[which((resultMatrix()$Identifier.1 ==  sucrose & resultMatrix()$NbValues != 1) | (resultMatrix()$Identifier.1 !=  sucrose & resultMatrix()$NbValues != 2))]

      if(length(error.nbValue) == 0) {

        "There is a no mistake in the number of values"

      } else {}

    } else {}

})

output$error.nbNA_Error <- renderText({

  if(!is.null(input$TCD)) {

  error.nbNA <- resultMatrix()$FirstLine[which(resultMatrix()$Nb.NA != 1)]

  if(length(error.nbNA) > 0) {
    paste("There is a mistake in the number of NA value. Check the line(s):", paste(error.nbNA, sep = " ", collapse = " "))
  } else {}

  } else {}
})

output$error.nbNA_OK <- renderText({

  if(!is.null(input$TCD)) {

  error.nbNA <- resultMatrix()$FirstLine[which(resultMatrix()$Nb.NA != 1)]

  if(length(error.nbNA) == 0) {
    "There is a no mistake in the number of values"
  } else {}

  } else {}
})

############################
## Condition 3: For sample, all identifier.2 of a single analysis should be not empty and identical
############################
dataTables <- reactive({

  if(!is.null(input$TCD)) {

    sample <- input$sample

    place <- NULL

    for(x in 1:length(sample)) {

      if(x == 1) {
        TCD.sample <- resultMatrix()[which(resultMatrix()$Identifier.1 == sample[x]), ]
        place <- which(resultMatrix()$Identifier.1 == sample[x])
      } else {
         TCD.sample <- rbind(TCD.sample, resultMatrix()[which(resultMatrix()$Identifier.1 == sample[x]), ])
        place <- c(place, which(resultMatrix()$Identifier.1 == sample[x]))
      }
    }

    place <- sort(place)

    PlaceBar <- complementVector(1:nrow(resultMatrix()), place)

    TCD.sample <- TCD.sample[order(TCD.sample$FirstLine),] # data with only the sample

    TCD.standard <- resultMatrix()[PlaceBar, ] # data with only the standards

    return(list(TCD.sample, TCD.standard))

  } else {}
})

dataStandard <- reactive({

  if(!is.null(input$TCD)) {

   dataTables()[[2]]

  } else {}
})

dataSample <- reactive({

  if(!is.null(input$TCD)) {

   dataTables()[[1]]

  } else {}
})

output$dataSampleToPrint <- renderDT({

  if(!is.null(input$TCD)) {

    dataSample()

  } else {}
})

output$dataStandardToPrint <- renderDT({

  if(!is.null(input$TCD)) {

    dataStandard()

  } else {}
})

output$error_id.2_Error <- renderText({

  if(!is.null(input$TCD)) {

    error_id.2 <- resultMatrix()$FirstLine[which(resultMatrix()$error_id.2 != 0)]

    if(length(error_id.2) != 0) {
    paste("Some analysis show different name in their identifier.2. Please check in the analysis line(s)", paste(error_id.2, sep = " ", collapse = " "))
    } else {}

  } else {}
})

output$error_id.2_OK <- renderText({

  if(!is.null(input$TCD)) {

  error_id.2 <- resultMatrix()$FirstLine[which(resultMatrix()$error_id.2 != 0)]

  if(length(error_id.2) == 0) {
    "All the identifier.2 values are identical within a single analysis"
  } else {}

  } else {}
})

output$error.id2.sample_Error <- renderText({

  if(!is.null(input$TCD)) {

  error.id2.sample <- resultMatrix()$FirstLine[which(resultMatrix()$error.id2.sample != 0)]

  if(length(error.id2.sample) != 0) {
    paste("Some analysis show an empty identifier.2. Please check in the analysis line(s)", paste(error.id2.sample, sep = " ", collapse = " "))
  } else {}

  } else {}

})

output$error.id2.sample_OK <- renderText({

  if(!is.null(input$TCD)) {

  error.id2.sample <- resultMatrix()$FirstLine[which(resultMatrix()$error.id2.sample != 0)]

  if(length(error.id2.sample) == 0) {
    "No identifier is empty in sample, great :)"
  } else {}

  } else {}

})

############################
## Condition 4: identifier.2 for weight and TCD file shoule be in the same order
############################

Data_plus_weight <- reactive({ ## for pasting the weight of the sample

  if(!is.null(input$TCD) & !is.null(input$weightData)) {

  errorToCount <- 0 # flag for error
  line.flag <- NA

  Data_plus_weight <- NULL

  nRow.dataSample <- nrow(dataSample())

  nRow.weightData <- nrow(weightData())

  if(nRow.dataSample != nRow.weightData) {
    errorToCount <- 1
  } else {
      for(i in 1:nRow.dataSample){
        if(as.character(dataSample()$Identifier.2[i]) != as.character(weightData()$Box.pos[i])){
          errorToCount <- 1
          line.flag <- dataSample()$Identifier.2[i]
          } else {}
      }
      if(errorToCount == 0) {
        Data_plus_weight <- cbind(dataSample(), weightData()$Name, weightData()$Measured.Weigth..mg.)
        colnames(Data_plus_weight)[10:11] <- c("sampleName", "SampleWeight")
      } else {}
  }

  return(list(c(errorToCount, line.flag), Data_plus_weight))

  } else {}
})

output$weight_Error <- renderText({

  if(!is.null(input$TCD) & !is.null(input$weightData)) {

  if(Data_plus_weight()[[1]][1] != 0){
    if(!is.na(Data_plus_weight()[[1]][2])){
      paste("Weight and TCD files do not match on their identifier.2, check line(s):", paste(Data_plus_weight()[[1]][2], sep = " ", collapse = " "))
    } else {
            paste("Weight and TCD files do not have the same number of rows")
    }
  } else {
    NULL
  }

  } else {}
})

output$weight_OK <- renderText({

  if(!is.null(input$TCD) & !is.null(input$weightData)) {

  if(Data_plus_weight()[[1]][1] != 0){
      NULL
  } else {
    "The weight file seems correct (Note that it did not check for the box name)"
  }

  } else {}
})
```
------------------------------------------------------------------------------------------------------------------------------

### Conditions tested for cleaning
1. Condition 1: No identifier.1 should not be empty
`r textOutput("id1_OK")`
**`r textOutput("id1_Error")`**
<br>
2. Condition 2: rArea Flash TCD with exactly three lines (for the sucrose, two lines) containing exactly two values (respectively one) and an empty cell (NA accepted)
`r textOutput("error.nbValue_OK")`
**`r textOutput("error.nbValue_Error")`**
`r textOutput("error.nbNA_OK")`
**`r textOutput("error.nbNA_Error")`**
<br>
3. Condition 3: All identifier.2 of a single analysis should be not empty and identical (samples only)
**`r textOutput("error_id.2_Error")`**
`r textOutput("error_id.2_OK")`
**`r textOutput("error.id2.sample_Error")`**
`r textOutput("error.id2.sample_OK")`
<br>
4. Condition 4: identifier.2 for weight and TCD file shoule be in the same order (for sample only)
**`r textOutput("weight_Error")`**
`r textOutput("weight_OK")`
<br>

#### **Data Samples:**
<br>
`r DTOutput("dataSampleToPrint")`
<br><br>

#### **Data Standards:**
<br>
`r DTOutput("dataStandardToPrint")`
<br>

------------------------------------------------------------------------------------------------------------------------------

### Graphical detection of mistakes - Outlier highlighting
```{r}

output$forBoxPlot <- renderUI({
  if(!is.null(input$TCD)) {

 level.identifier.1 <- levels(TCD()$Identifier.1)

 checkboxGroupInput("toDisplay", label = "",
    choices = level.identifier.1,
    selected = level.identifier.1, 
     inline = T )

  } else {}

})


output$boxplot <- renderPlot({

  if(!is.null(input$TCD)) {
    

    toDisplay <- input$toDisplay

    for(x in 1:length(toDisplay)) {

      if(x == 1) {
        dataTemp <- resultMatrix()[which(resultMatrix()$Identifier.1 == toDisplay[x]), ]
      } else {
         dataTemp <- rbind(dataTemp, resultMatrix()[which(resultMatrix()$Identifier.1 == toDisplay[x]), ])
      }
    }
    
      
      par(mfrow = c(1,2), mar = c(2,3,1.2,1.2))

    ylim.C  <- c(min(dataTemp$rArea.Flash.TCD.C, na.rm = T) - abs(min(dataTemp$rArea.Flash.TCD.C, na.rm = T))*0.1, max(dataTemp$rArea.Flash.TCD.C, na.rm = T) + abs(max(dataTemp$rArea.Flash.TCD.C, na.rm = T))*0.1)

    boxplot.with.outlier.label(as.numeric(as.character(dataTemp$rArea.Flash.TCD.C)), label_name = dataTemp$Identifier.2, ylim = ylim.C, cex = 1.25)

    mtext("rArea.Flash.TCD.C", side = 1)

    ylim.N  <- c(min(dataTemp$rArea.Flash.TCD.N, na.rm = T) - abs(min(dataTemp$rArea.Flash.TCD.N, na.rm = T))*0.1, max(dataTemp$rArea.Flash.TCD.N, na.rm = T) + abs(max(dataTemp$rArea.Flash.TCD.N, na.rm = T))*0.1)


    boxplot.with.outlier.label(as.numeric(as.character(dataTemp$rArea.Flash.TCD.N)), label_name = dataTemp$Identifier.2, ylim = ylim.N, cex = 1.25)

    mtext("rArea.Flash.TCD.N", side = 1)
    
    
  } else {}

})
```
`r uiOutput('forBoxPlot')`
`r plotOutput('boxplot')`
<br><br>

------------------------------------------------------------------------------------------------------------------------------

### Conclusions of the cleaning

```{r}
finalConclusion <- reactive({

  if(!is.null(resultMatrix())) {

  error_id.2 <- resultMatrix()$FirstLine[which(resultMatrix()$error_id.2 != 0)]
  error.id2.sample <- resultMatrix()$FirstLine[which(resultMatrix()$error.id2.sample != 0)]

  error.nbNA <- resultMatrix()$FirstLine[which(resultMatrix()$Nb.NA != 1)]
  
  TCD.liste <- split(TCD(), TCD()$Identifier.1)

  TCD.liste <- TCD.liste[which(names(TCD.liste) != "")]

  sucrose <- names(TCD.liste)[str_detect(names(TCD.liste), "ucrose")]

  error.nbValue <- resultMatrix()$FirstLine[which((resultMatrix()$Identifier.1 ==  sucrose & resultMatrix()$NbValues != 1) | (resultMatrix()$Identifier.1 !=  sucrose & resultMatrix()$NbValues != 2))]
  
  if(!is.null(Data_plus_weight())) {
    
      if(length(bad.Id1()) != 0 | length(error_id.2) != 0 | length(error.id2.sample) != 0 | Data_plus_weight()[[1]][1] != 0 | length(error.nbNA) != 0 | length(error.nbValue) != 0) {
    return(TRUE)
  } else {return(FALSE)}
    
  } else {return(TRUE)}

  } else {return(TRUE)}


})

output$finalConclusion_error <- renderText({
  if(!is.null(resultMatrix())) {

  if(finalConclusion() == TRUE) {
    "There is at least one mistake in your files. <br> Please correct according to previously before continuing to read this file."
  } else {NULL}

  } else {NULL}
})

output$finalConclusion_OK <- renderText({

  if(!is.null(resultMatrix())) {
    
    if(finalConclusion() == FALSE) {
    "It seems that your files are correct."
    } else {NULL}
  } else {NULL}
  
})


```
`r textOutput("finalConclusion_OK")`
**`r span(htmlOutput("finalConclusion_error"), style="color:red")`**
<br>

------------------------------------------------------------------------------------------------------------------------------

### Settings for "Quant.file" creation
**WARNING:** Before continuing in this file, please check the conditions above do **NOT** contain any error in required **CONCLUSIONS** (this task may require several run of utilisation of the function TCD_cleanR). If the TCD file is upload without this last verification, Quant.CreatR **CANNOT** garantee the validity of the following data.
<br><br>
`r uiOutput("info.2")`
```{r}
output$info.2 <- renderUI({

  backgroundValues <- c(0, 1167)
  content.GelA <- c(0.16, 0.42)
  
  gelA <- levels(Data_plus_weight_table()$sampleName)[(str_detect(levels(Data_plus_weight_table()$sampleName), "el")| str_detect(levels(Data_plus_weight_table()$sampleName), "EL"))]
  
  if(length(gelA) == 0) {
    gelA <- levels(Data_plus_weight_table()$sampleName)[1]
  }

  div(column(6,
             textInput("N.background", label = "N background value for Area.Flash.TCD.N", value = backgroundValues[1]),
             textInput("N.gelA", label = "GelA N content", value = content.GelA[1])
             ),
      (column(6,
              textInput("C.background", label = "C background value for Area.Flash.TCD.C", value = backgroundValues[2]),
              textInput("C.gelA", label = "GelA C content", value = content.GelA[2])
      )
      ),
      column(12, 
             checkboxGroupInput("gelA.Name.input", label = p("Choose the name that correspond to GelA"),
                                choices = levels(Data_plus_weight_table()$sampleName),
                                selected = gelA,
                                inline =T)
             )
  )
})

backgroundValues <- reactive({
  return(c(as.numeric(as.character(input$N.background)), as.numeric(as.character(input$C.background))))
})

Data_plus_weight_table <- reactive({

   if(!is.null(Data_plus_weight())) {

  tempTable <- Data_plus_weight()[[2]]

  tempTable[,3] <- tempTable[,10] #(remove the Firstline)
  tempTable[,4] <- tempTable[,11] # remove the number of value

  tempTable <- tempTable[,-c(5,6,7,10,11)]

  Rank.Analysis <- 1:nrow(tempTable)

  tempTable <- cbind(Rank.Analysis, tempTable)

  colnames(tempTable) <- c("Rank.Analysis","Identifier.1", "Identifier.2", "sampleName", "SampleWeight", "rArea.Flash.TCD.N", "rArea.Flash.TCD.C")

  return(tempTable)

   } else {}
})

content.GelA <- reactive({
  return(c(as.numeric(as.character(input$N.gelA)), as.numeric(as.character(input$C.gelA))))
})

Data_plus_weight_corrected <- reactive({

  if(!is.null(Data_plus_weight_table())) {

  corrected.N <- Data_plus_weight_table()$rArea.Flash.TCD.N - backgroundValues()[1]
  corrected.C <- Data_plus_weight_table()$rArea.Flash.TCD.C - backgroundValues()[2]

  temp <- cbind(Data_plus_weight_table(), corrected.N, corrected.C)
  colnames(temp)[8:9] <- c("Corrected.Area.N", "Corrected.Area.C")

  return(temp)
  } else {}

})

GelA.table <- reactive({

  if(!is.null(Data_plus_weight_table())) {

    for(x in 1:length(input$gelA.Name.input)) {

      if(x == 1) {
        gelA <- Data_plus_weight_corrected()[which(Data_plus_weight_corrected()$sampleName == input$gelA.Name.input[x]), ]
      } else {
         gelA <- rbind(gelA, Data_plus_weight_corrected()[which(Data_plus_weight_corrected()$sampleName == input$gelA.Name.input[x]), ])
      }
    }
    
    temp <- matrix()
    
    for(x in 1: (nrow(gelA) + 1)) {

      if(x == 1) {
        
        temp <- c(0, "Blank", as.character("Blank"), as.character("Blank"), 0, as.numeric(as.character(backgroundValues())), as.numeric(as.character(backgroundValues())))
      } else {
         temp <- rbind(temp, gelA[x-1, ])
      }
    }
    
    mg.N.perCup <- as.numeric(as.character(temp$SampleWeight)) * content.GelA()[1] * 1000
    mg.C.perCup <- as.numeric(as.character(temp$SampleWeight)) * content.GelA()[2] * 1000
    
    temp <- cbind(temp, mg.N.perCup, mg.C.perCup)
    
    temp$Rank.Analysis <- as.numeric(as.character(temp$Rank.Analysis))
    
    temp <- temp[order(temp$Rank.Analysis), ]
    
    colnames(temp) <- c(colnames(Data_plus_weight_corrected()), "mg.N.perCup", "mg.C.perCup")
    
    temp2 <- c("Blank", as.character(temp[,3]))
    
    temp[,3] <- temp2[-2]
    
    temp3 <- c("Blank", as.character(temp[,4]))
    
    temp[,4] <- temp3[-2]

  return(temp)
  } else {}

  })

output$check <- renderTable({
  GelA.table()
})


```

     
------------------------------------------------------------------------------------------------------------------------------

### GelA linear regression

<br><br>

#### **1. Nitrogen** 

```{r}
output$GelA.tokeep.N <- renderUI({
  
  if(!is.null(Data_plus_weight_table())) {
               checkboxGroupInput("GelA.tokeep.N", label = p("Select the gelA to keep for the linear regression"),
                                choices = GelA.table()$Identifier.2,
                                selected = GelA.table()$Identifier.2, 
                                inline = T )
    
  } else {}
})

tableGelA.tokeep.N <- reactive({
  
    if(!is.null(Data_plus_weight_table())) {

    for(x in 1:length(input$GelA.tokeep.N)) {

      if(x == 1) {
        tableGelA.tokeep.N <- GelA.table()[which(GelA.table()$Identifier.2 == input$GelA.tokeep.N[x]), ]
      } else {
         tableGelA.tokeep.N <- rbind(tableGelA.tokeep.N, GelA.table()[which(GelA.table()$Identifier.2 == input$GelA.tokeep.N[x]), ])
      }
    }
      return(tableGelA.tokeep.N)
    } else {}
  
})

model.N <- reactive({
  model.N.NR <- lm(as.numeric(as.character(tableGelA.tokeep.N()$rArea.Flash.TCD.N)) ~ as.numeric(as.character(tableGelA.tokeep.N()$mg.N.perCup)))
  Intercept.N <- summary(model.N.NR)$coefficients[1]
  Slope.N <- summary(model.N.NR)$coefficients[2]
  
  return(c(Intercept.N, Slope.N))
})

output$linearRegression.N <- renderPlot({
  plot(as.numeric(as.character(tableGelA.tokeep.N()$rArea.Flash.TCD.N)) ~ as.numeric(as.character(tableGelA.tokeep.N()$mg.N.perCup)), ylab = "rArea.Flash.TCD.N", xlab = "mg.N.perCup")
  text(as.numeric(as.character(tableGelA.tokeep.N()$mg.N.perCup)), as.numeric(as.character(tableGelA.tokeep.N()$rArea.Flash.TCD.N)), labels=as.character(tableGelA.tokeep.N()$Identifier.2), cex= 0.7, pos=4)
  abline(model.N()[1], model.N()[2], col = 'red')
})

output$modelN <- renderText({
  paste("For N, the parameter of the model: intercept = ", round(model.N()[1],2), " and slope = ", round(model.N()[2], 2))
})
```
`r uiOutput("GelA.tokeep.N")`
<br>
`r plotOutput('linearRegression.N')`
`r textOutput('modelN')`
<br><br>

#### **2. Carbon** 

```{r}

output$GelA.tokeep.C <- renderUI({

  if(!is.null(Data_plus_weight_table())) {
               checkboxGroupInput("GelA.tokeep.C", label = p("Select the gelA to keep for the linear regression"),
                                choices = GelA.table()$Identifier.2,
                                selected = GelA.table()$Identifier.2,
                                inline = T )

  } else {}
})

tableGelA.tokeep.C <- reactive({

    if(!is.null(Data_plus_weight_table())) {

    for(x in 1:length(input$GelA.tokeep.C)) {

      if(x == 1) {
        tableGelA.tokeep.C <- GelA.table()[which(GelA.table()$Identifier.2 == input$GelA.tokeep.C[x]), ]
      } else {
         tableGelA.tokeep.C <- rbind(tableGelA.tokeep.C, GelA.table()[which(GelA.table()$Identifier.2 == input$GelA.tokeep.C[x]), ])
      }
    }
      return(tableGelA.tokeep.C)
    } else {}

})

model.C <- reactive({
  model.C.NR <- lm(as.numeric(as.character(tableGelA.tokeep.C()$rArea.Flash.TCD.C)) ~ as.numeric(as.character(tableGelA.tokeep.C()$mg.C.perCup)))
  Intercept.C <- summary(model.C.NR)$coefficients[1]
  Slope.C <- summary(model.C.NR)$coefficients[2]

  return(c(Intercept.C, Slope.C))
})

output$linearRegression.C <- renderPlot({
  plot(as.numeric(as.character(tableGelA.tokeep.C()$rArea.Flash.TCD.C)) ~ as.numeric(as.character(tableGelA.tokeep.C()$mg.C.perCup)), ylab = "rArea.Flash.TCD.C", xlab = "mg.C.perCup")
  text(as.numeric(as.character(tableGelA.tokeep.C()$mg.C.perCup)), as.numeric(as.character(tableGelA.tokeep.C()$rArea.Flash.TCD.C)), labels=as.character(tableGelA.tokeep.C()$Identifier.2), cex= 0.7, pos=4)
  abline(model.C()[1], model.C()[2], col = 'red')
})

output$modelC <- renderText({
  paste("For N, the parameter of the model: intercept = ", round(model.C()[1],2), " and slope = ", round(model.C()[2], 2))
})
```
`r uiOutput("GelA.tokeep.C")`
<br>
`r plotOutput('linearRegression.C')`
`r textOutput('modelC')`
<br><br>

------------------------------------------------------------------------------------------------------------------------------

### Creation of the final "Quant" file

```{r}
finalTable.Sample <- reactive({
  
  if(!is.null(Data_plus_weight_table())) {
  
  Weight.N.perCup <- Data_plus_weight_corrected()$Corrected.Area.N/model.N()[2]
  Weight.C.perCup <- Data_plus_weight_corrected()$Corrected.Area.C/model.C()[2]
  
  Weight.N.kg <- Weight.N.perCup/Data_plus_weight_corrected()$SampleWeight*1000
  Weight.C.kg <- Weight.C.perCup/Data_plus_weight_corrected()$SampleWeight*1000

  C.N.Ratio <- Weight.C.kg/Weight.N.kg

  temporary.TCDtable <- cbind(Data_plus_weight_corrected(),Weight.N.perCup, Weight.C.perCup, Weight.N.kg, Weight.C.kg, C.N.Ratio)
  
  for(i in 5:12) {
    temporary.TCDtable[,i] <- as.numeric(as.character(temporary.TCDtable[,i]))
  }
  
  return(temporary.TCDtable)
  
  } else {}
  
})

output$tableSample.ToDisplay <- renderDT({
  
  if(!is.null(Data_plus_weight_table())) {
  
  if(input$nameSession == "Name of the session") {
    toAdd <- ""
  } else {
    toAdd <- input$nameSession
  }
    
  table0 <- matrix("", 24, 2)
     
table0[,1] <- c("Total C and D Quantification Analysis", 
                "", 
                "1. Session settings",
                "Date", 
                "Samples", 
                "Responsible", 
                "Lab. Temp", 
                "System", 
                "Column", 
                "Temp, Owen", 
                "Carrier gas", 
                "Carrier flow", 
                "Reference gas1",
                "Reference flow", 
                "Reference gas2",
                "Reference flow", 
                "Method", 
                "Content of N in Gel A house standard",
                "Content of C in Gel A house standard",
                "N background value for Area.Flash.TCD.N",
                "C background value for Area.Flash.TCD.C", 
                "", "",
                "2. GelA table"
)
table0[,2] <- c("", 
                "", 
                "", 
                input$dateProcessig, 
                input$SampleName, 
                input$Responsible, 
                input$Temperature, 
                input$system, 
                input$Column, 
                input$temp.Owen, 
                input$carrier.Gas, 
                input$carrier.flow, 
                input$Reference.gas1,
                input$Reference.flow1, 
                input$Reference.gas2,
                input$Reference.flow2, 
                input$Method, 
                input$N.gelA,
                input$C.gelA,
                input$N.background,
                input$C.background,
                "", "", 
                ""
)  

normStyle <- createStyle(valign = "center", halign = "center", numFmt = "0.00")
GeneraltitleStyle <- createStyle(valign = "center", halign = "center", fontSize = 14, textDecoration = "bold")
titleStyle <- createStyle(valign = "center", halign = "left", fontSize = 14, textDecoration = "bold")
tableStyle <- createStyle(borderStyle = "thin", border = "TopBottomLeftRight")
colorPurple <- createStyle(fgFill = "#800080")
colorGreen <- createStyle(fgFill = "#99cc00")

table.Interm1 <- matrix("3. General Table", ncol = 1, nrow = 1)

wb <- createWorkbook("Example.xlsx")

addWorksheet(wb, "TCD_data")
writeData(wb, sheet = 1, TCD(), colNames = T)

addWorksheet(wb, "quantification_data")

writeData(wb, sheet = 2, table0, colNames = FALSE)
writeData(wb, sheet = 2, GelA.table(), startRow = nrow(table0) + 1, colNames = T)
writeData(wb, sheet = 2, table.Interm1, startRow = nrow(table0) + 4 + nrow(GelA.table()), colNames = F)
writeData(wb, sheet = 2, finalTable.Sample(), startRow = nrow(table0) + 5 + nrow(GelA.table()), colNames = T)

nbRow_FinalTable <- nrow(table0) + 5 + nrow(GelA.table()) + nrow(finalTable.Sample())

lapply(1:14, function(x) {
  addStyle(wb, sheet = 2, normStyle, cols = x, rows = 1:nbRow_FinalTable)
})

lapply(1:11, function(x) {
  addStyle(wb, sheet = 2, tableStyle, cols = x, rows = 25:(25+nrow(GelA.table())), stack = T)
})

finalTable_begin <- nrow(table0) + 5 + nrow(GelA.table())
finalTable_end <- nrow(table0) + 5 + nrow(GelA.table()) + nrow(finalTable.Sample())

lapply(1:14, function(x) {
  addStyle(wb, sheet = 2, tableStyle, cols = x, rows = finalTable_begin:finalTable_end, stack = T)
})

addStyle(wb, sheet = 2, GeneraltitleStyle, rows = 1, cols = 1, stack = T)
addStyle(wb, sheet = 2, titleStyle, rows = 3, cols = 1, stack = T)
addStyle(wb, sheet = 2, titleStyle, rows = nrow(table0), cols = 1, stack = T)
addStyle(wb, sheet = 2, titleStyle, rows = nrow(table0) + 4 + nrow(GelA.table()), cols = 1, stack = T)

addStyle(wb, sheet = 2, colorPurple, cols = 12, rows = finalTable_begin:finalTable_end, stack = T)
addStyle(wb, sheet = 2, colorPurple, cols = 13, rows = finalTable_begin:finalTable_end, stack = T)
addStyle(wb, sheet = 2, colorGreen, cols = 14, rows = finalTable_begin:finalTable_end, stack = T)

mergeCells(wb, sheet = 2, cols = 1:18, rows = 1)
mergeCells(wb, sheet = 2, cols = 1:8, rows = 3)
mergeCells(wb, sheet = 2, cols = 1:8, rows = nrow(table0))
mergeCells(wb, sheet = 2, cols = 1:8, rows = nrow(table0) + 4 + nrow(GelA.table()))

saveWorkbook(wb, file = paste0("finalTable.Sample_",toAdd, ".xlsx" ), overwrite = TRUE)

  return(finalTable.Sample())
  
  } else {}
})

output$nameFile <- renderText({
  if(!is.null(Data_plus_weight_table())) {
    
     
  if(input$nameSession == "Name of the session") {
    toAdd <- ""
  } else {
    toAdd <- input$nameSession
  }
    
    paste("This table has already been saved in an excel sheet called: ", paste0("finalTable.Sample_",toAdd, ".csv" ))
    
  } else {}
})

```

#### **Final Sample table**
<br><br>
`r DTOutput('tableSample.ToDisplay')`
<br>
**OBS: **
`r textOutput("nameFile")`
<br><br>

------------------------------------------------------------------------------------------------------------------------------

### Data exploration

```{r}
output$pivot <- renderRpivotTable({
  rpivotTable(finalTable.Sample(),width="100%", height="400px")
})
```
`r rpivotTableOutput('pivot')`

<br><br><br><br>

