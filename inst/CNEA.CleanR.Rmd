---
title: "CNEA.CleanR"
author: "Charlotte S."
date: "7 f√©vrier 2018"
output: 
  html_document:
    code_folding: hide
runtime: shiny
---


```{r include=FALSE, cache=FALSE}
# function to ask for the background values
inputs <- function(generalText, TextInput.1, TextInput.2){
  
  xvar <- tclVar("")
  yvar <- tclVar("")
  
  tt <- tktoplevel()
  tkwm.title(tt,paste("Choose", generalText))
  x.entry <- tkentry(tt, textvariable=xvar)
  y.entry <- tkentry(tt, textvariable=yvar)
  
  reset <- function()
  {
    tclvalue(xvar)<-""
    tclvalue(yvar)<-""
  }
  
  reset.but <- tkbutton(tt, text="Reset", command=reset)
  
  submit <- function() {
    x <- as.numeric(tclvalue(xvar))
    y <- as.numeric(tclvalue(yvar))
    e <- parent.env(environment())
    e$x <- x
    e$y <- y
    tkdestroy(tt)
  }
  submit.but <- tkbutton(tt, text="submit", command=submit)
  tkgrid(tklabel(tt,text=TextInput.1), x.entry, pady = 10, padx =10)
  tkgrid(tklabel(tt,text=TextInput.2), y.entry, pady = 10, padx =10)
  tkgrid(submit.but, reset.but)
  
  tkwait.window(tt)
  return(c(x,y))
}

separateAnalysis <- function(data, column1, column2) {
  
  vect1 <- which(is.na(column1))
  listPlace1 <- successiveValues(vect1)
  
  vect2 <- which(is.na(column2))
  listPlace2 <- successiveValues(vect2)
  
  if(length(listPlace1) != 0 | length(listPlace2) != 0) {
    if(length(listPlace1) == length(listPlace2)) {

    toReturn <-  lapply(1:length(listPlace1), function(x) {
      data[c(listPlace1[[x]],listPlace2[[x]]), ]
    })

  } else {
    toReturn <- NULL
  }
  } else {
      toReturn <- NULL
    }
  
  
  return(toReturn)
}

successiveValues = function(vect) {
                          
                          if(length(vect) != 1) {
                            
                            length.vect <- length(vect)
                            
                            i <- 1
                            k <- 1
                            
                            finalList <- list()
                            
                            while(i < length.vect) {
                              
                              finalList[k][[1]] <- vect[i]
                              
                              while(vect[i + 1] == vect[i] +1 & i < length.vect) {
                                
                                finalList[k][[1]] <- c(finalList[k][[1]], vect[i+1])
                                
                                i <- i+1
                                
                              }
                              
                              i <- i+1
                              k <- k+1
                              
                            }
                            
                            if(length(unlist(finalList)) != length.vect) {
                              finalList[[k]] <- vect[length.vect]
                            }
                            
                          } else {
                            finalList <- list(vect)
                          }
                          

                          
                          return(finalList)
                          
}

                        # some helpful threads
                        # https://stat.ethz.ch/pipermail/r-help/2008-September/172641.html
                        # http://tolstoy.newcastle.edu.au/R/e4/help/08/02/4875.html
                        # http://tolstoy.newcastle.edu.au/R/e2/help/07/01/8598.html
                        
                        # http://www.r-statistics.com/wp-content/uploads/2011/01/boxplot-add-label-for-outliers.r.txt
                        
                        # last updated: 31.10.2011
                        # 		This is instead of the 20.6.11 version...
                        
                        boxplot.with.outlier.label <- function(y, label_name, ..., spread_text = T, data, plot = T, range = 1.5, label.col = "blue", push_text_right = 1.3, # enlarge push_text_right in order to push the text labels further from their point
                                                               segement_width_as_percent_of_label_dist = .45, # Change this if you want to have the line closer to the label (range should be between 0 to 1
                                                               jitter_if_duplicate = T, jitter_only_positive_duplicates = F)
                        {	
                          # notes - this functions doesn't work if there are any missing values in the data.
                          #		You must pre-process the data to make sure it is "complete".
                          
                          
                          # change log:
                          # 19.04.2011 - added support to "names" and "at" parameters.
                          
                          
                          # jitter_if_duplicate - will jitter (Actually just add a bit of numbers) so to be able to decide on which location to plot the label when having identical variables...
                          require(plyr) # for is.formula and ddply
                          
                          # a function to jitter data in case of ties in Y's
                          jitter.duplicate <- function(x, only_positive = F)
                          {
                            if(only_positive) {
                              ss <- x > 0
                            } else {
                              ss <- T
                            }	
                            ss_dup <- duplicated(x[ss])
                            # ss <- ss & ss_dup
                            temp_length <- length(x[ss][ss_dup])	
                            x[ss][ss_dup] <- x[ss][ss_dup] + seq(from = 0.00001, to = 0.00002, length.out = temp_length)
                            x
                          }
                          # jitter.duplicate(c(1:5))
                          # jitter.duplicate(c(1:5,5,2))
                          # duplicated(jitter.duplicate(c(1:5,5,2)))
                          # jitter.duplicate(c(0,0,1:5,5,2))
                          # duplicated(jitter.duplicate(c(0,0,1:5,5,2)))
                          
                          
                          
                          # handle cases where 
                          if(jitter_if_duplicate) {
                            # warning("duplicate jutter of values in y is ON")
                            if(!missing(data)) {	#e.g: we DO have data
                              # if(exists("y") && is.formula(y)) {		# F && NULL # F & NULL
                              y_name <- as.character(substitute(y))	# I could have also used as.list(match.call())
                              # credit to Uwe Ligges and Marc Schwartz for the help
                              # https://mail.google.com/mail/?shva=1#inbox/12dd7ca2f9bfbc39
                              if(length(y_name) > 1) {	# then it is a formula (for example: "~", "y", "x"
                                model_frame_y <- model.frame(y, data = data)
                                temp_y <- model_frame_y[,1]
                                temp_y  <- jitter.duplicate(temp_y, jitter_only_positive_duplicates)	# notice that the default of the function is to work only with positive values...
                                # the_txt <- paste(names(model_frame_y)[1], "temp_y", sep = "<<-") # wrong...
                                the_txt <- paste("data['",names(model_frame_y)[1],"'] <- temp_y", sep = "")				
                                eval(parse(text = the_txt))	# jutter out y var so to be able to handle identical values.
                              } else {	# this isn't a formula
                                data[,y_name] <- jitter.duplicate(data[,y_name], jitter_only_positive_duplicates)
                                y <- data[,y_name]	# this will make it possible for boxplot(y, data) to work later (since it is not supposed to work with data when it's not a formula, but now it does :))
                              }		
                            } else {	# there is no "data"		 
                              if(is.formula(y)) { # if(exists("y") && is.formula(y)) {		# F && NULL # F & NULL
                                temp_y <- model.frame(y)[,1]
                                temp_y  <- jitter.duplicate(temp_y, jitter_only_positive_duplicates)	# notice that the default of the function is to work only with positive values...
                                temp_y_name <- names(model.frame(y))[1]	# we must extract the "names" before introducing a new enbironment (or there will be an error)
                                environment(y) <- new.env()
                                assign(temp_y_name, temp_y, environment(y))
                                # Credit and thanks for doing this goes to Niels Richard Hansen (2 Jan 30, 2011)
                                # http://r.789695.n4.nabble.com/environment-question-changing-variables-from-a-formula-through-model-frame-td3246608.html
                                # warning("Your original variable (in the global environemnt) was just jittered.")	# maybe I should add a user input before doing this....
                                # the_txt <- paste(names(model_frame_y)[1], "temp_y", sep = "<<-")
                                # eval(parse(text = the_txt))	# jutter out y var so to be able to handle identical values.
                              } else {
                                y <- jitter.duplicate(y, jitter_only_positive_duplicates)
                              }		
                            }
                          }
                          # the_txt <- paste("print(",names(model_frame_y)[1], ")")
                          # eval(parse(text = the_txt))	# jutter out y var so to be able to handle identical values.
                          # print(ls())
                          
                          
                          # y should be a formula of the type: y~x, y~a*b
                          # or it could be simply y
                          if(missing(data)) {
                            boxdata <- boxplot(y, plot = plot,range = range ,...)
                          } else {
                            boxdata <- boxplot(y, plot = plot,data = data, range = range ,...)
                          }
                          if(length(boxdata$names) == 1 && boxdata$names =="") boxdata$names <- 1	# this is for cases of type: boxplot(y) (when there is no dependent group)
                          if(length(boxdata$out) == 0 ) {
                            warning("No outliers detected for this boxplot")
                            return(invisible())
                          }
                          
                          if(!missing(data)) attach(data)	# this might lead to problams I should check out for alternatives for using attach here...
                          
                          
                          # creating a data.frame with information from the boxplot output about the outliers (location and group)
                          boxdata_group_name <- factor(boxdata$group)
                          levels(boxdata_group_name) <- boxdata$names[as.numeric(levels(boxdata_group_name))]	# the subseting is for cases where we have some sub groups with no outliers
                          if(!is.null(list(...)$at))	{	# if the user chose to use the "at" parameter, then we would like the function to still function (added on 19.04.2011)
                            boxdata$group <- list(...)$at[boxdata$group]		
                          }
                          boxdata_outlier_df <- data.frame(group = boxdata_group_name, y = boxdata$out, x = boxdata$group)
                          
                          
                          # Let's extract the x,y variables from the formula:
                          if(is.formula(y))
                          {
                            model_frame_y <- model.frame(y)
                            # old solution: (which caused problems if we used the names parameter when using a 2 way formula... (since the order of the names is different then the levels order we get from using factor)
                            # y <- model_frame_y[,1]
                            # x <- model_frame_y[,-1]
                            
                            y <- model_frame_y[,1]
                            x <- model_frame_y[,-1]
                            if(!is.null(dim(x))) {	# then x is a matrix/data.frame of the type x1*x2*..and so on - and we should merge all the variations...
                              x <- apply(x,1, paste, collapse = ".")
                            }
                          } else {
                            # if(missing(x)) x <- rep(1, length(y))
                            x <- rep(1, length(y))	# we do this in case y comes as a vector and without x
                          }	
                          
                          # and put all the variables (x, y, and outlier label name) into one data.frame
                          DATA <- data.frame(label_name, x ,y)
                          
                          if(!is.null(list(...)$names))	{	# if the user chose to use the names parameter, then we would like the function to still function (added on 19.04.2011)
                            DATA$x <- factor(DATA$x, levels = unique(DATA$x))
                            levels(DATA$x) = list(...)$names	# enable us to handle when the user adds the "names" parameter # fixed on 19.04.11	# notice that DATA$x must be of the "correct" order (that's why I used split above
                            # warning("Careful, the use of the 'names' parameter is experimental.  If you notice any errors please e-mail me at: tal.galili@gmail.com")
                          }
                          
                          if(!missing(data)) detach(data)	# we don't need to have "data" attached anymore.
                          
                          # let's only keep the rows with our outliers 
                          boxplot.outlier.data <- function(xx, y_name = "y")
                          {
                            y <- xx[,y_name]
                            boxplot_range <- range(boxplot.stats(y, coef = range )$stats)
                            ss <- (y < boxplot_range[1]) | (y > boxplot_range[2])
                            return(xx[ss,])	
                          }
                          outlier_df <-ddply(DATA, .(x), boxplot.outlier.data)
                          
                          
                          # create propor x/y locations to handle over-laping dots...
                          if(spread_text) {
                            # credit: Greg Snow
                            require(TeachingDemos)		
                            temp_x <- boxdata_outlier_df[,"x"]
                            temp_y1 <- boxdata_outlier_df[,"y"]
                            temp_y2 <- temp_y1
                            for(i in unique(temp_x))
                            {
                              tmp <- temp_x == i
                              temp_y2[ tmp ] <- spread.labs( temp_y2[ tmp ], 1.3*strheight('A'), maxiter=6000, stepsize = 0.05) #, min=0 )
                            }
                            
                          }
                          
                          
                          
                          # max(strwidth(c("asa", "a"))
                          # move_text_right <- max(strwidth(outlier_df[,"label_name"]))	
                          
                          # plotting the outlier labels :)  (I wish there was a non-loop wise way for doing this)
                          for(i in seq_len(dim(boxdata_outlier_df)[1]))
                          {
                            # ss <- (outlier_df[,"x"]  %in% boxdata_outlier_df[i,]$group) & (outlier_df[,"y"] %in% boxdata_outlier_df[i,]$y)
                            
                            # if(jitter_if_duplicate) {
                            # ss <- (outlier_df[,"x"]  %in% boxdata_outlier_df[i,]$group) & closest.number(outlier_df[,"y"]  boxdata_outlier_df[i,]$y)
                            # } else {
                            ss <- (outlier_df[,"x"]  %in% boxdata_outlier_df[i,]$group) & (outlier_df[,"y"] %in% boxdata_outlier_df[i,]$y)
                            # }
                            
                            current_label <- outlier_df[ss,"label_name"]
                            temp_x <- boxdata_outlier_df[i,"x"]
                            temp_y <- boxdata_outlier_df[i,"y"]		
                            # cbind(boxdata_outlier_df,		temp_y2)
                            # outlier_df
                            
                            
                            
                            if(spread_text) {
                              temp_y_new <- temp_y2[i] # not ss			
                              move_text_right <- strwidth(current_label) * push_text_right
                              text( temp_x+move_text_right, temp_y_new, current_label, col = label.col)			
                              # strwidth
                              segments( temp_x+(move_text_right/6), temp_y, temp_x+(move_text_right*segement_width_as_percent_of_label_dist), temp_y_new )
                            } else {
                              text(temp_x, temp_y, current_label, pos = 4, col = label.col)
                            }		
                          }
                          
                          # outputing some of the information we collected
                          invisible(list(boxdata = boxdata, boxdata_outlier_df = boxdata_outlier_df, outlier_df=outlier_df))
                        }
```
<br><br>

### To read beforhand

**Aim of this document:** This sheet has been created to help users to format the CN_EA file in order to upload it for further calculations. <br><br>
**WARNING:** The aim of CN_EA.CleanR is **not** to correct automatically the CN_EA file, this delicated task requiring human skills. However, it is dedicated to point out errors or abnormalities of the raw CN_EA file. When the first round of correction has been finished and before uploading any file in isoSignature.creatR, please check a last time with CN_EA.CleanR that there is **NO** error in the required **CONCLUSIONS** (this task may require several rounds of CN_EA.CleanR).
<br><br>

### 1. Import of the raw data of signature

```{r} 
# tkmessageBox(message = "Choose a signature file", type = "ok")
# CN_EA.path <- tclvalue(tkgetOpenFile())
# if (!nchar(CN_EA.path)) {
#  tkmessageBox(message = "No file was selected!")
# } else {
#  tkmessageBox(message = paste("The file selected was", CN_EA.path))
# }
```

```{r} 
CN_EA.path <- "/home/cha/Dropbox/Post-doc_Danemark/Results/Script/CNEA.xls"
CN_EA.data <- read.xls(xls = CN_EA.path, sheet = 1, header = TRUE)

Rank.Analysis <- 2: (nrow(CN_EA.data)+ 1) # +1 to make the excel file correspond to the R file

CN_EA.data <- cbind(Rank.Analysis, CN_EA.data)

nrow.CN_EA <- nrow(CN_EA.data)
ncol.CN_EA <- ncol(CN_EA.data)

# Identifier.1 <- colnames(TCD)[3] # first identifer name (e.g. box name or standard used)
# Identifier.2 <- colnames(TCD)[4] # Second identifer name (i.e. place of the sample in the box)
```
The CN_EA file chosen is `r CN_EA.path`
<br><br>

### 2. Conditions tested by CNEA.CleanR

* **Necessary conditions (i.e. corrections mandatory for IsoSignature.creatR) **
    + **Any identifier 1 should not be empty or null**
    + **One analysis (i.e. the ranks are following) must contain not empty Area.All cell. d13C/d12C and d15N/d14N should have each at least one value.**
* Secondary conditions (i.e. corrections are not mandatory, CNEA.CleanR just mentionned them to warn user)
    + Analysis should have exactly one dilution value
    + Every analysis must begin with 3 or 4 d15N/d14N and last with 2 values of d13C/d12C  
<br><br>


### 3. Any identifier 1 should not be empty or null

```{r} 
level.identifier.1 <- levels(CN_EA.data$Identifier.1)

bad.Id1 <- which(CN_EA.data$Identifier.1 == "" | is.na(CN_EA.data$Identifier.1) | is.null(CN_EA.data$Identifier.1))

if(length(bad.Id1) != 0) {
  CN_EA.data <- CN_EA.data[-bad.Id1, ]
  
  toDisplay.1 <- paste("Some identifier.1 are empty. Please remove the line:", paste(bad.Id1, sep = " ", collapse = ""))
  
} else {
   toDisplay.1 <- "No problem in the identifier.1"
}
```
<br>
**CONCLUSIONS:** `r toDisplay.1`
<br><br>

### 4. Value requirement validation 
Here, CN_EA.CleanR controles for errors and abnormalities that **have to be controled and corrected** by the user. 
```{r} 
CN_EA.data.liste <- split(CN_EA.data, CN_EA.data$Identifier.1)

CN_EA.data.liste <- CN_EA.data.liste[which(names(CN_EA.data.liste) != "")]

resultMatrix <- matrix(NA,ncol = 4) #the matrix summurizing the number of values for d13C and d15N
signature.Table <- matrix(NA,ncol = 6) # the final matrix with the signature

error.dilution <- vector()

for(i in 1:length(CN_EA.data.liste)) {
  
  dataProv <- CN_EA.data.liste[[i]]
  
  One.Analysis <- separateAnalysis(dataProv, column1 = dataProv$d.13C.12C, column2 = dataProv$d.15N.14N)
  
  number.Analysis <- length(One.Analysis)
  
  for(j in 1:number.Analysis) {
    
    ### deal with dilution 
    
    dilution <- One.Analysis[[j]]$Sample.Dilution
    
    not0 <- which(dilution != 0)
    
    length.not0 <- length(which(duplicated(dilution[not0]) == FALSE))
    
    if(length.not0 != 1){
      
      error.dilution <- c(error.dilution, One.Analysis[[j]]$Rank.Analysis[1])
      
    } else {}
    
    d13C <- which(!is.na(One.Analysis[[j]]$d.13C.12C) & !is.null(One.Analysis[[j]]$d.13C.12C) & One.Analysis[[j]]$d.13C.12C != "")
    d15N <- which(!is.na(One.Analysis[[j]]$d.15N.14N) & !is.null(One.Analysis[[j]]$d.15N.14N) & One.Analysis[[j]]$d.15N.14N != "")
    
    toAdd <- c(names(CN_EA.data.liste)[i], One.Analysis[[j]]$Rank.Analysis[1], length(d13C), length(d15N))
    
    resultMatrix <- rbind(resultMatrix, toAdd)
    
    toAdd.signture <- c(names(CN_EA.data.liste)[i], One.Analysis[[j]]$Rank.Analysis[1], as.character(One.Analysis[[j]]$Identifier.2[1]), One.Analysis[[j]]$d.15N.14N[d15N[length(d15N)]], dilution[not0[1]], One.Analysis[[j]]$d.13C.12C[d13C[1]])
    
    signature.Table <- rbind(signature.Table, toAdd.signture)
  }
}

resultMatrix <- resultMatrix[-1,]

signature.Table <- signature.Table[-1,]

colnames(resultMatrix) <- c("identifier.1", "FirstLine", "Nb.d13C", "Nb.d15N")
resultMatrix <- as.data.frame(resultMatrix)

colnames(signature.Table) <- c("identifier.1", "FirstLine", "identifier.2","d13C", "dilution", "d15N")
rownames(signature.Table) <- seq(1:nrow(signature.Table))
signature.Table <- as.data.frame(signature.Table)


## detect the error

error.d13C <- which(as.numeric(as.character(resultMatrix$Nb.d13C)) == 0 | resultMatrix$Nb.d13C == "")
error.d15N <- which(as.numeric(as.character(resultMatrix$Nb.d15N)) == 0 | resultMatrix$Nb.d15N == "")

is.error.d13C <- length(error.d13C)
is.error.d15N <- length(error.d15N)
```

**CONCLUSIONS FOR D13C:** <br>
`r if(is.error.d13C != 0) {paste("Some lines of the CN_EA file are missing values. Please check line(s)", paste(error.d13C, sep = " ", collapse = " "))} else {"Your file is OK"} `
<br><br>
**CONCLUSIONS FOR D15N:** <br>
`r if(is.error.d15N != 0) {paste("Some lines of the CN_EA file are missing values. Please check line(s)", paste(error.d15N, sep = " ", collapse = " "))} else {"Your file is OK"} `
<br><br>

### 5. Mistakes that only require a warning
Here, CN_EA.CleanR shows some abnormalities that have to be controled by the user. Those abnormalities do not require a correction, but a simple checking.

```{r}
## detect weirdlines (i.e. different that 2 analysis for d13C and different than 3 or 4 for d15N)

length.error.dilution <- length(error.dilution)

weird.d13C <- which(as.numeric(as.character(resultMatrix$Nb.d13C)) != 2)
weird.d15N <- which(as.numeric(as.character(resultMatrix$Nb.d15N)) != 4 & as.numeric(as.character(resultMatrix$Nb.d15N)) != 3)

is.weird.d13C <- length(weird.d13C)
is.weird.d15N <- length(weird.d15N)

```

**CONCLUSIONS FOR DILUTION:** <br>
`r if(length.error.dilution != 0) {paste("Some dilutions are not the same for a same analysis. Please check the analyis line(s)", paste(error.dilution, sep = " ", collapse = " "))} else {"Your file is OK"} `
<br><br>
**CONCLUSIONS FOR D13C:** <br>
`r if(is.weird.d13C != 0) {paste("Some lines of the CN_EA file have too much or too few values. Please check line(s)", paste(weird.d13C, sep = " ", collapse = " "))} else {"Your file is OK"} `
<br><br>
**CONCLUSIONS FOR D15N:** <br>
`r if(is.weird.d15N != 0) {paste("Some lines of the CN_EA file have too much or too few values. Please check line(s)", paste(weird.d15N, sep = " ", collapse = " "))} else {"Your file is OK"} `
<br><br>

### 6. Visual checking
This part displays the d13C signatures and d15N signatures (CNEA.CleanR automatically takes the last value for the d15N and the first value for the d13C)) to detect potential errors in the CN_EA file. Check it out ;)

```{r}

level.identifier.1 <- levels(CN_EA.data$Identifier.1)

radioButtons("toDisplay", label = "",
    choices = level.identifier.1,
    selected = level.identifier.1[1])

output$boxplot <- renderPlot({

  if(!is.null(input$toDisplay)) {
    dataToPlot <- split(signature.Table, signature.Table$identifier.1)
    
    dataTemp <- dataToPlot[which(names(dataToPlot) == input$toDisplay)]
    
    par(mfrow = c(1,2), mar = c(2,3,1.2,1.2))
    
    ylim.d13C  <- c(min(as.numeric(as.character(dataTemp[[1]]$d13C)), na.rm = T) - abs(min(as.numeric(as.character(dataTemp[[1]]$d13C)), na.rm = T))*0.1, max(as.numeric(as.character(dataTemp[[1]]$d13C)), na.rm = T) + abs(max(as.numeric(as.character(dataTemp[[1]]$d13C)), na.rm = T))*0.1)
    
    boxplot.with.outlier.label(as.numeric(as.character(dataTemp[[1]]$d13C)), label_name = dataTemp[[1]]$identifier.2, ylim = ylim.d13C, cex = 1.25)
    
    mtext("d13C", side = 1)
    
    ylim.d15N  <- c(min(as.numeric(as.character(dataTemp[[1]]$d15N)), na.rm = T) - abs(min(as.numeric(as.character(dataTemp[[1]]$d15N)), na.rm = T))*0.1, max(as.numeric(as.character(dataTemp[[1]]$d15N)), na.rm = T) + abs(max(as.numeric(as.character(dataTemp[[1]]$d15N)), na.rm = T))*0.1)

    
    boxplot.with.outlier.label(as.numeric(as.character(dataTemp[[1]]$d15N)), label_name = dataTemp[[1]]$identifier.2, ylim = ylim.d15N)
    
    mtext("d15N", side = 1)
  } else {}
  
})
```
`r plotOutput('boxplot')`
<br><br>

### **Conclusions **
Please, correct the potential mistakes highlighted by CN_EA.CleanR and upload your CN_EA file to finally check that there is longer any problem before using isoSign.creatR
<br><br>









