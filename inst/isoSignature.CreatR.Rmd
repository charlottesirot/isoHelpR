---
title: "isoSignature.creatR"
author: "Charlotte S"
date: "15 f√©vrier 2018"
output: 
  html_document:
    code_folding: hide
runtime: shiny
---

### **To Read Beforehand**

**Aim of this document:** This sheet has been created to generate automatically the "isotope_data" file based on the CN_EA data. Moreover, some data exploration are provided at the end of this document <br>
**WARNING:** Before uploading the file in isoSignature.creatR, please check with the CNEA_CleanR that the raw CN_EA file does **NOT** contain any error in required **CONCLUSIONS** (this task may require several run of utilisation of the function TCD_cleanR). If the CN_EA file is upload without this last verification, isoSignature.creatR **CANNOT** garantee the validity of the following data.
<br><br>

```{r include=FALSE, cache=FALSE}
separateAnalysis <- function(data, column1, column2) {
  
  vect1 <- which(is.na(column1))
  listPlace1 <- successiveValues(vect1)
  
  vect2 <- which(is.na(column2))
  listPlace2 <- successiveValues(vect2)
  
  if(length(listPlace1) == length(listPlace2)) { 
    
    toReturn <-  lapply(1:length(listPlace1), function(x) {
      data[c(listPlace1[[x]],listPlace2[[x]]), ]
    })
    
  } else {
    toReturn <- NULL
  }
  return(toReturn)
}
successiveValues = function(vect) {
                          
                          if(length(vect) != 1) {
                            
                            length.vect <- length(vect)
                            
                            i <- 1
                            k <- 1
                            
                            finalList <- list()
                            
                            while(i < length.vect) {
                              
                              finalList[k][[1]] <- vect[i]
                              
                              while(vect[i + 1] == vect[i] +1 & i < length.vect) {
                                
                                finalList[k][[1]] <- c(finalList[k][[1]], vect[i+1])
                                
                                i <- i+1
                                
                              }
                              
                              i <- i+1
                              k <- k+1
                              
                            }
                            
                            if(length(unlist(finalList)) != length.vect) {
                              finalList[[k]] <- vect[length.vect]
                            }
                            
                          } else {
                            finalList <- list(vect)
                          }
                          

                          
                          return(finalList)
                          
}
complementVector = function(VectR, x) {
                          
                          length.VectR <- length(VectR)
                          length.x <- length(x)
                          
                          y <- vector() #output
                          
                          for(i in 1:length.VectR) {
                            
                            if(is.na(match(VectR[i], x))) {
                              y <- c(y, i)
                            } else {}
                            
                          }
                          
                          return(VectR[y])
                          
                        }
blank.correction <- function(Area.blank, Sign.blank, Area.sample, Sign.sample) {
  value <- (Area.sample*Sign.sample - Area.blank*Sign.blank)/(Area.sample - Area.blank)
  return(value)
}
Area.correction <- function(value.toCorrect, dilution) {
  value <- value.toCorrect * (1+dilution/100)
  return(value)
}
Karina.Normalisation <- function(signature, true.Values, real.Values){
  coef <- (true.Values[1] - true.Values[2])/(real.Values[1]-real.Values[2])
  
  value <- (signature - real.Values[2]) * coef + true.Values[2]
  
  return(value)
}
Peter.Correction.d15N <- function(signature, rank, slope, intercept) {
  newValue <- signature - (slope * rank + intercept - 5.4) 
  return(newValue)
}
Peter.Correction.d13C <- function(signature, rank, slope, intercept) {
  newValue <- signature - (slope * rank + intercept + 21.8) 
  return(newValue)
}
max.list = function(liste) {
                          
                          max.list <- 0
                          
                          n <- length(liste)
                          
                          for (i in 1:n) {
                            
                            max.Prov <- length(liste[[i]])
                            
                            if(max.Prov > max.list) {max.list <- max.Prov} else {}
                            
                          }
                          
                          return(max.list)
                        }
```

### **Information about the session**
```{r echo = FALSE} 
textInput("dateProcessig", label = "", value = "Date of the analysis:")
textInput("Responsible", label = "", value = "Responsible:")
textInput("Temperature", label = "", value = "Lab Temperature:")
textInput("SampleName", label = "", value = "Sample name:")
textInput("system", label = "", value = "System:")
textInput("Column", label = "", value = "Column:")
textInput("temp.Owen", label = "", value = "Temp Owen:")
textInput("carrier.Gas", label = "", value = "Carrier gas:")
textInput("carrier.flow", label = "", value = "Carrier flow:")
textInput("Reference.gas1", label = "", value = "Reference gas 1:")
textInput("Reference.flow1", label = "", value = "Reference flow1:")
textInput("Reference.gas2", label = "", value = "Reference gas 2:")
textInput("Reference.flow2", label = "", value = "Reference flow2:")
textInput("Method", label = "", value = "Method:")
```
<br><br>

### 1. Import of the raw data of signature

```{r} 
# tkmessageBox(message = "Choose a signature file", type = "ok")
# CN_EA.path <- tclvalue(tkgetOpenFile())
# if (!nchar(CN_EA.path)) {
#  tkmessageBox(message = "No file was selected!")
# } else {
#  tkmessageBox(message = paste("The file selected was", CN_EA.path))
# }
CN_EA.path <- "/home/cha/Dropbox/Post-doc_Danemark/Results/Script/CNEA.xls"
CN_EA.data <- read.xls(xls = CN_EA.path, sheet = 1, header = TRUE)

Rank.Analysis <- 2: (nrow(CN_EA.data)+ 1) # +1 to make the excel file correspond to the R file

CN_EA.data <- cbind(Rank.Analysis, CN_EA.data)

nrow.CN_EA <- nrow(CN_EA.data)
ncol.CN_EA <- ncol(CN_EA.data)

level.identifier.1 <- levels(CN_EA.data$Identifier.1)
```
The CN_EA file chosen is `r CN_EA.path`
<br><br>

### 2. Import the weight data
**WARNING:** Before uploading the weight file, please check that the order in TCD file and weight files are the same (checked in the next calculation but the calculations will be stop if this condition is not respected).
```{r} 
# tkmessageBox(message = "Choose the file containing the weight of your sample", type = "ok")
# weightPath <- tclvalue(tkgetOpenFile())
# if (!nchar(weightPath)) {
#  tkmessageBox(message = "No file was selected!")
# } else {
#  tkmessageBox(message = paste("The file selected was", weightPath))
# }
weightPath <- "/home/cha/Dropbox/Post-doc_Danemark/Results/Script/weight.csv"
weightData <- read.csv(weightPath, h = T, dec = ".", sep = ",")
nRow.weightData <- nrow(weightData)
```
The TCD file chosen is `r weightPath`
<br><br>

### 2. Settings for creating the signature file
```{r}
CN_EA.data.liste <- split(CN_EA.data, CN_EA.data$Identifier.1)

CN_EA.data.liste <- CN_EA.data.liste[which(names(CN_EA.data.liste) != "")]

signature.Table <- matrix(NA,ncol = 8) # the final matrix with the signature

for(i in 1:length(CN_EA.data.liste)) {
  
  dataProv <- CN_EA.data.liste[[i]]
  
  One.Analysis <- separateAnalysis(dataProv, column1 = dataProv$d.13C.12C, column2 = dataProv$d.15N.14N)
  
  number.Analysis <- length(One.Analysis)
  
  for(j in 1:number.Analysis) {
    
    dilution <- One.Analysis[[j]]$Sample.Dilution
    
    not0 <- which(dilution != 0)
    
    d13C <- which(!is.na(One.Analysis[[j]]$d.13C.12C) & !is.null(One.Analysis[[j]]$d.13C.12C) & One.Analysis[[j]]$d.13C.12C != "")
    d15N <- which(!is.na(One.Analysis[[j]]$d.15N.14N) & !is.null(One.Analysis[[j]]$d.15N.14N) & One.Analysis[[j]]$d.15N.14N != "")
    
    areaC <- One.Analysis[[j]]$Area.All[d13C[1]]
    areaN <- One.Analysis[[j]]$Area.All[d15N[1]]
    
    toAdd.signture <- c(names(CN_EA.data.liste)[i], One.Analysis[[j]]$Rank.Analysis[1], as.character(One.Analysis[[j]]$Identifier.2[1]), areaN, One.Analysis[[j]]$d.15N.14N[d15N[length(d15N)]], dilution[not0[1]], areaC, One.Analysis[[j]]$d.13C.12C[d13C[1]])
    
    signature.Table <- rbind(signature.Table, toAdd.signture)
  }
}

signature.Table <- signature.Table[-1,]

colnames(signature.Table) <- c("identifier.1", "FirstLine", "identifier.2", "Area.N", "d15N", "dilution", "Area.C", "d13C")
rownames(signature.Table) <- seq(1:nrow(signature.Table))
signature.Table <- as.data.frame(signature.Table)

checkboxGroupInput("sample", label = p("1. Select which one are samples"), 
    choices = level.identifier.1,
    selected = level.identifier.1[1],
    inline = T)
```


----------------------------------------------------------------------------------------------------------------

```{r}
blank <- names(CN_EA.data.liste)[str_detect(names(CN_EA.data.liste), "lank")]

checkboxGroupInput("blank", label = p("2. Select blanks (blank AND system blank)"), 
    choices = level.identifier.1,
    selected = blank,
    inline = T)
```


----------------------------------------------------------------------------------------------------------------

```{r}
checkboxGroupInput("gelA", label = p("3. Select Gel A"), 
    choices = levels(weightData$Name),
    selected = levels(weightData$Name)[1],
    inline =T)
```



----------------------------------------------------------------------------------------------------------------

```{r}
output$checkBox.N <- renderUI({
  checkboxGroupInput("N.define", label = p("4. Select nitrogen standards"), 
    choices = level.identifier.1,
    selected = level.identifier.1[1],
    inline = F)
})


output$Value.N <- renderUI({
  plot_output_list <- lapply(seq(from = 1, to = length(level.identifier.1), by = 1), function(i) {
								V.N <- paste("value.N", i, sep="")
								textInput(V.N, label = "", value = paste("Value N for ", level.identifier.1[i]))
    })
})

n.ToTake <- reactive({
  n.ToTake <- sapply(1:length(input$N.define), function(x) {
    which(input$N.define[x] == level.identifier.1)
  })
  n.ToTake <- sort(n.ToTake)
  
  return(n.ToTake) ## rank of value to take
})

value.N <- reactive({
  
  temp <- vector()
  
  for(i in 1:length(level.identifier.1)){

    temp <- c(temp, eval(parse(text = paste("input$value.N", i, sep=""))))

  }
  
  return(temp)
})

value.N.toTake <- reactive({
  
  temp <- value.N()[n.ToTake()]
  
  names(temp) <- level.identifier.1[n.ToTake()]
  
  return(temp)
  
})


```
`r div(column(6, uiOutput("checkBox.N")), column(6, uiOutput("Value.N")))` 
 -1- 


----------------------------------------------------------------------------------------------------------------


```{r}

output$checkBox.C <- renderUI({
checkboxGroupInput("C.define", label = p("5. Select carbon standards"), 
    choices = level.identifier.1,
    selected = level.identifier.1[1],
    inline = F)
})


output$Value.C <- renderUI({
  plot_output_list <- lapply(seq(from = 1, to = length(level.identifier.1), by = 1), function(i) {
								V.C <- paste("value.C", i, sep="")
								textInput(V.C, label = "", value = paste("Value C for ", level.identifier.1[i]))
    })
})

c.ToTake <- reactive({
  c.ToTake <- sapply(1:length(input$C.define), function(x) {
    which(input$C.define[x] == level.identifier.1)
  })
  c.ToTake <- sort(c.ToTake)
  
  return(c.ToTake) ## rank of value to take
})

value.C <- reactive({
  
  temp <- vector()
  
  for(i in 1:length(level.identifier.1)){

    temp <- c(temp, eval(parse(text = paste("input$value.C", i, sep=""))))

  }
  
  return(temp)
})

value.C.toTake <- reactive({
  
  temp <- value.C()[c.ToTake()]
  
  names(temp) <- level.identifier.1[c.ToTake()]
  
  return(temp)
  
})

```
`r div(column(6, uiOutput("checkBox.C")), column(6, uiOutput("Value.C")))`

```{r}
#############################################################################################################################
### Table1 is the first table of the isotope data sheet that allow to have the average of the NItrogen and Carbon standards
#############################################################################################################################

table1 <- reactive({
  
  nitrogen.table1 <- list()

for(i in 1:length(input$N.define)) {
  
  dataTemp <- signature.Table[which(signature.Table$identifier.1 == input$N.define[i]),]
  
  nitrogen.table1[[i]] <- dataTemp$d15N
  
}

carbon.table1 <- list()

for(i in 1:length(input$C.define)) {
  
  dataTemp <- signature.Table[which(signature.Table$identifier.1 == input$C.define[i]),]
  
  carbon.table1[[i]] <- dataTemp$d13C
  
}

nrow.table1 <- max(max.list(nitrogen.table1), max.list(carbon.table1)) + 5
ncol.table1 <- length(input$C.define) + length(input$N.define)+1

table1 <- as.data.frame(matrix(ncol = ncol.table1, nrow = nrow.table1)) ## Blank corrected delta values for isotope standards

table1[1,] <- c("Blank corrected delta values for isotope standards", rep("Nitrogen", length(input$N.define)), rep("Carbon", length(input$C.define)))
table1[2,] <- c(" ", input$N.define, input$C.define)

for(i in 1:length(input$N.define)) {
  
  table1[3:(2+length(nitrogen.table1[[i]])),i+1] <- as.character(nitrogen.table1[[i]])
  
}

for(i in 1:length(input$C.define)) {
  
  table1[3:(2+length(carbon.table1[[i]])),i+length(input$N.define)+1] <- as.character(carbon.table1[[i]])
  
}

table1[3:(nrow(table1)-3),1] <- " "

table1[(nrow(table1)-2) : nrow(table1), 1] <- c("Average", "Stdev", "True.Value")

for(i in 2:(length(input$C.define) + length(input$N.define) + 1)) {
  
  analysis <- as.numeric(as.character(table1[,i]))
  
  table1[(nrow.table1-2),i] <- mean(analysis, na.rm = T)
  table1[(nrow.table1-1),i] <- sd(analysis, na.rm = T)
}

table1[nrow.table1,(2:ncol.table1)] <- c(as.numeric(as.character(value.N.toTake())), as.numeric(as.character(value.C.toTake())))

colnames(table1) <- c("Names", paste("Nitrogen", input$N.define, sep ="."), paste("Carbon", input$C.define, sep ="."))

return(table1)
})

output$table1.toDisplay <- renderDT({
 table1()
}, rownames = FALSE)

```
`r DTOutput("table1.toDisplay")`

----------------------------------------------------------------------------------------------------------------

**6. Define the N background**
```{r}
backgroundValues <- c(0, 1167)

div(
  column(6, 
         textInput("Area.N.background", label = "", value = "Area of the blank N")),
  column(6,
         textInput("signature.N.background", label = "", value = "signature of the blank N")))

div(
  column(6, 
         textInput("Area.C.background", label = "", value = "Area of the blank C")),
  column(6,
         textInput("signature.C.background", label = "", value = "signature of the blank C")))
```



```{r}
#############################################################################################################################
### creation of the table2: table2.standard (i.e. called Blank correction of delta value in standards) and table2.sample
#############################################################################################################################

table2 <- reactive({
  
  signature.Table <- signature.Table[order(as.numeric(as.character(signature.Table$FirstLine))),]
  
  line.sample  <- lapply(1:length(input$sample), function(x) {
    which(signature.Table$identifier.1 == input$sample [x]) 
    }) # the line of the signature.Table that correspond to the sample
  
  line.sample <- unlist(line.sample) 
  
  table2.sample.Temp <- signature.Table[line.sample,]
  
  table2.sample.Temp <- table2.sample.Temp[order(as.numeric(as.character(table2.sample.Temp$FirstLine))),]
  
  line.standard <- complementVector(1:nrow(signature.Table), line.sample)
  
  table2.standard.Temp <- signature.Table[line.standard,]
  
  table2.standard.Temp <- table2.standard.Temp[order(as.numeric(as.character(table2.standard.Temp$FirstLine))),]

  ## table2.standard final (i.e. with corrected value)
  
  table2.standard <- as.data.frame(matrix(ncol = 16, nrow = nrow(table2.standard.Temp)))
  
  colnames(table2.standard) <- c("Box.No", "Box.position", "sample.name", "sample.weight","Area.N", "d14N.d15N.ratio", "d14N.d15N.BlankCorrected", "Normalized.d14N.d15N", "At.N", "equipement.dilution", "Area.C", "d12C.d13C.ratio", "Area.C.Corrected", "d12C.d13C.BlankCorrected", "Normalized.d12C.d13C", "At.C")

  table2.standard$Box.No <- " "
  table2.standard$Box.position <- " "

  table2.standard[,c(3,5,6)] <- cbind(as.character(table2.standard.Temp$identifier.1), as.numeric(as.character(table2.standard.Temp$Area.N)), as.numeric(as.character(table2.standard.Temp$d15N)))
  table2.standard[,10:12] <- cbind(as.numeric(as.character(table2.standard.Temp$dilution)), as.numeric(as.character(table2.standard.Temp$Area.C)), as.numeric(as.character(table2.standard.Temp$d13C)))

  blank.correction <- function(Area.blank, Sign.blank, Area.sample, Sign.sample) {
  value <- (Area.sample*Sign.sample - Area.blank*Sign.blank)/(Area.sample - Area.blank)
  return(value)
  }
  
  blankValue.N <- c(as.numeric(as.character(input$Area.N.background)), as.numeric(as.character(input$signature.N.background)))
  blankValue.C <- c(as.numeric(as.character(input$Area.C.background)), as.numeric(as.character(input$signature.C.background)))
  
  toConvert <- c(5,6, 10, 11, 12)

  for(i in 1:length(toConvert)) {
    table2.standard[,toConvert[i]] <-as.numeric(as.character(table2.standard[,toConvert[i]]))
  }

 ## Blank correction d15N

  blankCorrected.d15N <- sapply(1:nrow(table2.standard), function(x) {
    blank.correction(blankValue.N[1], blankValue.N[2], table2.standard$Area.N[x],table2.standard$d14N.d15N.ratio[x])
  })

  table2.standard$d14N.d15N.BlankCorrected <- blankCorrected.d15N

  ## Area Correction d13C

  Area.Corrected.d13C <- sapply(1:nrow(table2.standard), function(x) {
    Area.correction(table2.standard$Area.C[x], table2.standard$equipement.dilution[x])
  })

  table2.standard$Area.C.Corrected <- Area.Corrected.d13C

  ## blank correction d13C

  blankCorrected.d13C <- sapply(1:nrow(table2.standard), function(x) {
    blank.correction(blankValue.C[1], blankValue.C[2], table2.standard$Area.C.Corrected[x],table2.standard$d12C.d13C.ratio[x])
  })

  table2.standard$d12C.d13C.BlankCorrected <- blankCorrected.d13C

  ## table2.sample final (i.e. with corrected value)

  table2.sample <- as.data.frame(matrix(ncol = 16, nrow = nrow(table2.sample.Temp)))

  colnames(table2.sample) <- c("Box.No", "Box.position", "sample.name", "sample.weight","Area.N", "d14N.d15N.ratio", "d14N.d15N.BlankCorrected", "Normalized.d14N.d15N", "At.N", "equipement.dilution", "Area.C", "d12C.d13C.ratio", "Area.C.Corrected", "d12C.d13C.BlankCorrected", "Normalized.d12C.d13C", "At.C")

  table2.sample[,1:2] <- cbind(as.character(table2.sample.Temp$identifier.1), as.character(table2.sample.Temp$identifier.2))
  table2.sample[,5:6] <- cbind(as.numeric(as.character(table2.sample.Temp$Area.N)), as.numeric(as.character(table2.sample.Temp$d15N)))
  table2.sample[,10:12] <- cbind(as.numeric(as.character(table2.sample.Temp$dilution)), as.numeric(as.character(table2.sample.Temp$Area.C)), as.numeric(as.character(table2.sample.Temp$d13C)))

  toConvert <- c(5,6, 10, 11, 12)

  for(i in 1:length(toConvert)) {
    table2.sample[,toConvert[i]] <-as.numeric(as.character(table2.sample[,toConvert[i]]))
  }

# blank correction d15N

  blankCorrected.d15N <- sapply(1:nrow(table2.sample), function(x) {
    blank.correction(blankValue.N[1], blankValue.N[2], table2.sample$Area.N[x],table2.sample$d14N.d15N.ratio[x])
  })

  table2.sample$d14N.d15N.BlankCorrected <- blankCorrected.d15N

  ## Area Correction d13C

  Area.Corrected.d13C <- sapply(1:nrow(table2.sample), function(x) {
    Area.correction(table2.sample$Area.C[x], table2.sample$equipement.dilution[x])
  })

  table2.sample$Area.C.Corrected <- Area.Corrected.d13C

  ## blank correction d13C

  blankCorrected.d13C <- sapply(1:nrow(table2.sample), function(x) {
    blank.correction(blankValue.C[1], blankValue.C[2], table2.sample$Area.C.Corrected[x],table2.sample$d12C.d13C.ratio[x])
  })

  table2.sample$d12C.d13C.BlankCorrected <- blankCorrected.d13C

  errorToCount <- 0 # flag for error

  line.flag <- NA

  nrow.table2.sample <- nrow(table2.sample)

  if(nrow.table2.sample != nRow.weightData) {
  errorToCount <- 1
} else {
  for(i in 1:nrow.table2.sample){
    if(table2.sample$Box.position[i] != as.character(weightData$Box.pos[i])){
      errorToCount <- 1
      line.flag <- table2.sample$Box.position[i]
    } else {}
  }
  if(errorToCount == 0) {
    table2.sample[,3:4] <- cbind(as.character(weightData$Name), weightData$Measured.Weigth..mg.)
  } else {}
}
    
  Rank.Analysis <- seq(1,nrow(table2.sample))

  table2.sample <- cbind(Rank.Analysis, table2.sample)

  return(list(table2.standard, table2.sample))
})

table2.standard <- reactive({
  table2()[[1]]
})

table2.sample <- reactive({
  table2()[[2]]
})

dilution <- reactive ({
  gelA.lines <- NULL
  
  for(i in 1:length(input$gelA)) {
  
  gelA.lines <- c(gelA.lines, which(table2.sample()$sample.name == input$gelA[i]))
  
}

gelA.table <- table2.sample()[gelA.lines,]

table.WithoutGelA <- table2.sample()[complementVector(1:nrow(table2.sample()), gelA.lines),]

## table of the dilution

dilution.Sample <- vector()

dilution.factor <- length(levels(as.factor(table.WithoutGelA$equipement.dilution)))

for(i in i:dilution.factor) {
  dilution.Sample[i] <- length(which(table.WithoutGelA$equipement.dilution == as.numeric(as.character(levels(as.factor(table.WithoutGelA$equipement.dilution))[i]))))
}

names(dilution.Sample) <- levels(as.factor(table.WithoutGelA$equipement.dilution))

dilution.Sample <- t(as.matrix(dilution.Sample))

rownames(dilution.Sample) <- "Number of sample analyzed with this dilution"

return(list(dilution.Sample, gelA.table, table.WithoutGelA))
})

gelA.table <- reactive({
  dilution()[[2]]
})

table.WithoutGelA <- reactive({
  dilution()[[3]]
})

output$dilutionTable <- renderTable({
  dilution()[[1]]
}, include.rownames=TRUE)

output$display <- renderTable({
  table.WithoutGelA()
})
 
dilution.suggested <- levels(as.factor(CN_EA.data$Sample.Dilution))
                                                                   
toPick.dilution <- dilution.suggested[which(dilution.suggested != "0" & dilution.suggested != " " & dilution.suggested != "" & !is.na(dilution.suggested))]

```

**7. Define the dilution factor to consider for the normalization (only for Peter's procedure) ** 

In the sample analyzed:

`r tableOutput('dilutionTable')`

Which dilution keeping for Peters' normalization:                                                                   

```{r echo = FALSE}
checkboxGroupInput("dilutionPicked", label = "",
                   choices = toPick.dilution,
                   selected = toPick.dilution[1],
                   inline = TRUE)
```
<br><br>

### 3. Creation of the final table
<br>

#### Karina's procedure of Normalization
<br>
Normalized.signature =  (Stand.1_TRUE - Stand.2_TRUE)/(Stand.1_OBS - Stand.2_OBS) * (signature - Stand.1_OBS) + Stand.1_TRUE
<br><br>
At (d15N) = 100/(271.872114/(1+(Normalized.signature/1000))+1)<br>
At (d13N) = 100/(89.443838/(1+(Normalized.signature/1000))+1)
```{r}
 table2.sample.Karina <- reactive({
                                                                     
table2.sample.Karina <- table2.sample()

norm.Karina.d15N <- sapply(1:nrow(table2.sample.Karina), function(x) {
  Karina.Normalisation(signature = table2.sample.Karina$d14N.d15N.BlankCorrected[x], true.Values = as.numeric(as.character(table1()[nrow(table1()),2:3])), real.Values =
as.numeric(as.character(table1()[(nrow(table1())-2),2:(length(input$N.define) +1)])))
})

table2.sample.Karina$Normalized.d14N.d15N <- norm.Karina.d15N

At.d15N <- 100/(271.872114/(1+(table2.sample.Karina$Normalized.d14N.d15N/1000))+1)

table2.sample.Karina$At.N <- At.d15N

norm.Karina.d13C <-  sapply(1:nrow(table2.sample.Karina), function(x) {
  Karina.Normalisation(signature = table2.sample.Karina$d12C.d13C.BlankCorrected[x], true.Values = as.numeric(as.character(table1()[nrow(table1()),4:5])), real.Values = as.numeric(as.character(table1()[(nrow(table1())-2),(length(input$N.define) +2):(length(input$N.define) +3)])))
})

table2.sample.Karina$Normalized.d12C.d13C <- norm.Karina.d13C

At.d13C <- 100/(89.443838/(1+(table2.sample.Karina$Normalized.d12C.d13C/1000))+1)

table2.sample.Karina$At.C <- At.d13C

return(table2.sample.Karina)
})

 output$dataSampleToPrint <- renderDT({
   
   if(length(input$C.define) > 1 & length(input$N.define) > 1 ) {
     table2.sample.Karina()
   } else {}
})


 
```
### Final Table
`r DTOutput("dataSampleToPrint")`

------------------------------------------------------------------------------------------

#### Peter's procedure of Normalization

```{r}

gelA.table.dilution <- reactive({
  gelA.table.dilution <- gelA.table()[which(gelA.table()$equipement.dilution == input$dilutionPicked), ]
  return(gelA.table.dilution)
})

model.15N <- reactive({
  model.d15N <- lm(gelA.table.dilution()$d14N.d15N.BlankCorrected ~ gelA.table.dilution()$Rank.Analysis)
  Intercept.N <- summary(model.d15N)$coefficients[1]
  Slope.N <- summary(model.d15N)$coefficients[2]
  return(c(Intercept.N, Slope.N))
})

model.13C <- reactive({
  model.d13C <- lm(gelA.table.dilution()$d12C.d13C.BlankCorrected ~ gelA.table.dilution()$Rank.Analysis)
  Intercept.C <- summary(model.d13C)$coefficients[1]
  Slope.C <- summary(model.d13C)$coefficients[2]
  return(c(Intercept.C, Slope.C))
})

output$linearRegression.N <- renderPlot({
  
  if(length(input$C.define) > 1 & length(input$N.define) > 1 ) {
    plot(gelA.table.dilution()$d14N.d15N.BlankCorrected ~ gelA.table.dilution()$Rank.Analysis, ylab = "d14N.d15N.BlankCorrected", xlab = "Rank.Analysis")
    text(gelA.table.dilution()$Rank.Analysis, gelA.table.dilution()$d14N.d15N.BlankCorrected, labels=gelA.table.dilution()$Box.position, cex= 0.7, pos=4)
    abline(model.15N()[1], model.15N()[2], col = 'red')
  } else {}
  
})

output$linearRegression.C <- renderPlot({
  
  if(length(input$C.define) > 1 & length(input$N.define) > 1 ) {
    plot(gelA.table.dilution()$d12C.d13C.BlankCorrected ~ gelA.table.dilution()$Rank.Analysis, ylab = "d12C.d13C.BlankCorrected", xlab = "Rank.Analysis")
    text(gelA.table.dilution()$Rank.Analysis, gelA.table.dilution()$d12C.d13C.BlankCorrected, labels=gelA.table.dilution()$Box.position, cex= 0.7, pos=4)
    abline(model.13C()[1], model.13C()[2], col = 'red')
  } else {}

})

table2.sample.Peter <- reactive({
  
  table2.sample.Peter <- table2.sample()
  
  Norm.d15N <- Peter.Correction.d15N(table2.sample.Peter$d14N.d15N.BlankCorrected, table2.sample.Peter$Rank.Analysis, model.15N()[2], model.15N()[1])
  
  table2.sample.Peter$Normalized.d14N.d15N <- Norm.d15N

  Norm.d13C <- Peter.Correction.d13C(table2.sample.Peter$d12C.d13C.BlankCorrected, table2.sample.Peter$Rank.Analysis, model.13C()[2], model.13C()[1])

  table2.sample.Peter$Normalized.d12C.d13C <- Norm.d13C
  
  return(table2.sample.Peter)
})

output$modelN <- renderText({
  if(length(input$C.define) > 1 & length(input$N.define) > 1 ) {
    paste("For N, the parameter of the model: intercept = ", round(model.15N()[1],10), " and slope = ", round(model.15N()[2], 10))
  } else {}
})

output$modelC <- renderText({
  
  if(length(input$C.define) > 1 & length(input$N.define) > 1 ) {
    paste("For C, the parameter of the model: intercept = ", round(model.13C()[1],10), " and slope = ", round(model.13C()[2], 10))
  } else {}
})

output$FinalTable <- renderDT({
  
  if(length(input$C.define) > 1 & length(input$N.define) > 1 ) {
   table2.sample.Peter()
  } else {}
  
  
})
```

* Linear regression d15N
`r textOutput('modelN')`
`r plotOutput('linearRegression.N')`

* Linear regression d13C
`r textOutput('modelC')`
`r plotOutput('linearRegression.C')`

### Final Table
`r DTOutput("FinalTable")`



















